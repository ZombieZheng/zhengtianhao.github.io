<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Zombies</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>不忘初心,砥砺前行</description>
    <pubDate>Thu, 17 Jun 2021 14:12:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>java类得高级特性</title>
      <link>http://example.com/2021/06/17/java%E7%B1%BB%E5%BE%97%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link>
      <guid>http://example.com/2021/06/17/java%E7%B1%BB%E5%BE%97%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid>
      <pubDate>Thu, 17 Jun 2021 13:20:27 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;类的高级特性&quot;&gt;&lt;a href=&quot;#类的高级特性&quot; class=&quot;headerlink&quot; title=&quot;类的高级特性&quot;&gt;&lt;/a&gt;类的高级特性&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="类的高级特性"><a href="#类的高级特性" class="headerlink" title="类的高级特性"></a>类的高级特性</h1><span id="more"></span><h2 id="Java类包"><a href="#Java类包" class="headerlink" title="Java类包"></a>Java类包</h2><h3 id="一个完整的类名需要报名与类名的组合-每个类都隶属于一个类包-只要保证同一个类包中的类不同命-就可以有效地避免同名类冲突的情况"><a href="#一个完整的类名需要报名与类名的组合-每个类都隶属于一个类包-只要保证同一个类包中的类不同命-就可以有效地避免同名类冲突的情况" class="headerlink" title="一个完整的类名需要报名与类名的组合,每个类都隶属于一个类包,只要保证同一个类包中的类不同命,就可以有效地避免同名类冲突的情况"></a>一个完整的类名需要报名与类名的组合,每个类都隶属于一个类包,只要保证同一个类包中的类不同命,就可以有效地避免同名类冲突的情况</h3><h3 id="在Java中采用类包机制非常重要-类包不仅可以解决类名冲突问题-还可以在开发庞大的引用程序时-帮助开发人员管理庞大的应用和层序组件-方便软件复用"><a href="#在Java中采用类包机制非常重要-类包不仅可以解决类名冲突问题-还可以在开发庞大的引用程序时-帮助开发人员管理庞大的应用和层序组件-方便软件复用" class="headerlink" title="在Java中采用类包机制非常重要,类包不仅可以解决类名冲突问题,还可以在开发庞大的引用程序时,帮助开发人员管理庞大的应用和层序组件,方便软件复用."></a>在Java中采用类包机制非常重要,类包不仅可以解决类名冲突问题,还可以在开发庞大的引用程序时,帮助开发人员管理庞大的应用和层序组件,方便软件复用.</h3><h3 id="同一个包中的类相互访问时-可以不指定包名"><a href="#同一个包中的类相互访问时-可以不指定包名" class="headerlink" title="同一个包中的类相互访问时,可以不指定包名."></a>同一个包中的类相互访问时,可以不指定包名.</h3><h3 id="同一个包中的类不必存放在同一个位置"><a href="#同一个包中的类不必存放在同一个位置" class="headerlink" title="同一个包中的类不必存放在同一个位置."></a>同一个包中的类不必存放在同一个位置.</h3><h3 id="Java包的命名规则是全部使用小写字母"><a href="#Java包的命名规则是全部使用小写字母" class="headerlink" title="Java包的命名规则是全部使用小写字母"></a>Java包的命名规则是全部使用小写字母</h3><hr><hr><h2 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h2><h3 id="final关键字可用于变量声明，一旦该变量被设定，就不可以再改变该变量的值。通常，由final定义的变量为常量。"><a href="#final关键字可用于变量声明，一旦该变量被设定，就不可以再改变该变量的值。通常，由final定义的变量为常量。" class="headerlink" title="final关键字可用于变量声明，一旦该变量被设定，就不可以再改变该变量的值。通常，由final定义的变量为常量。"></a>final关键字可用于变量声明，一旦该变量被设定，就不可以再改变该变量的值。通常，由final定义的变量为常量。</h3><h3 id="final关键字定义的变量必须再声明时对其进行赋值操作。final除了可以修饰基本数据类型的常量，还可以修饰对象引用-由于数组也可以被看作一个对象来引用，所以final可以修饰数组。"><a href="#final关键字定义的变量必须再声明时对其进行赋值操作。final除了可以修饰基本数据类型的常量，还可以修饰对象引用-由于数组也可以被看作一个对象来引用，所以final可以修饰数组。" class="headerlink" title="final关键字定义的变量必须再声明时对其进行赋值操作。final除了可以修饰基本数据类型的常量，还可以修饰对象引用,由于数组也可以被看作一个对象来引用，所以final可以修饰数组。"></a>final关键字定义的变量必须再声明时对其进行赋值操作。final除了可以修饰基本数据类型的常量，还可以修饰对象引用,由于数组也可以被看作一个对象来引用，所以final可以修饰数组。</h3><h3 id="一旦一个对象引用被修饰为final后，它只能恒定指向一个对象。"><a href="#一旦一个对象引用被修饰为final后，它只能恒定指向一个对象。" class="headerlink" title="一旦一个对象引用被修饰为final后，它只能恒定指向一个对象。"></a>一旦一个对象引用被修饰为final后，它只能恒定指向一个对象。</h3><h3 id="一个既是static又是final的字段只占据一段不能改变的存储空间"><a href="#一个既是static又是final的字段只占据一段不能改变的存储空间" class="headerlink" title="一个既是static又是final的字段只占据一段不能改变的存储空间."></a>一个既是static又是final的字段只占据一段不能改变的存储空间.</h3><h3 id="被定义为final的常量定义时需要使用大写字母命名，并且中间使用下划线进行连接，这是Java中的编码规则"><a href="#被定义为final的常量定义时需要使用大写字母命名，并且中间使用下划线进行连接，这是Java中的编码规则" class="headerlink" title="被定义为final的常量定义时需要使用大写字母命名，并且中间使用下划线进行连接，这是Java中的编码规则"></a>被定义为final的常量定义时需要使用大写字母命名，并且中间使用下划线进行连接，这是Java中的编码规则</h3><h3 id="同时，定义为final的数据无论是常量、对象引用还是数组，在主函数中都不可以被改变"><a href="#同时，定义为final的数据无论是常量、对象引用还是数组，在主函数中都不可以被改变" class="headerlink" title="同时，定义为final的数据无论是常量、对象引用还是数组，在主函数中都不可以被改变"></a>同时，定义为final的数据无论是常量、对象引用还是数组，在主函数中都不可以被改变</h3><h3 id="我们知道一个被定义为final的对象引用只能指向唯一一个对象，不可以将它再指向其他对象，但是一个对象本身的值确使可以改变的，那么为了使一个常量真正做到不可更改，可以将常量声明为static-final"><a href="#我们知道一个被定义为final的对象引用只能指向唯一一个对象，不可以将它再指向其他对象，但是一个对象本身的值确使可以改变的，那么为了使一个常量真正做到不可更改，可以将常量声明为static-final" class="headerlink" title="我们知道一个被定义为final的对象引用只能指向唯一一个对象，不可以将它再指向其他对象，但是一个对象本身的值确使可以改变的，那么为了使一个常量真正做到不可更改，可以将常量声明为static final"></a>我们知道一个被定义为final的对象引用只能指向唯一一个对象，不可以将它再指向其他对象，但是一个对象本身的值确使可以改变的，那么为了使一个常量真正做到不可更改，可以将常量声明为static final</h3><h3 id="在Java中定义全局常量，通常使用public-static-final修饰，这样的常量只能在定义是被赋值"><a href="#在Java中定义全局常量，通常使用public-static-final修饰，这样的常量只能在定义是被赋值" class="headerlink" title="在Java中定义全局常量，通常使用public static final修饰，这样的常量只能在定义是被赋值"></a>在Java中定义全局常量，通常使用public static final修饰，这样的常量只能在定义是被赋值</h3><h3 id="可以将方法的参数定义为final类型，这预示着无法为方法中更改参数引用所指向的对象"><a href="#可以将方法的参数定义为final类型，这预示着无法为方法中更改参数引用所指向的对象" class="headerlink" title="可以将方法的参数定义为final类型，这预示着无法为方法中更改参数引用所指向的对象"></a>可以将方法的参数定义为final类型，这预示着无法为方法中更改参数引用所指向的对象</h3><hr><hr><h2 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h2><h3 id="将方法定义为final类型可以防止子类修改该类的定义与实现方式，同时定义为final的方法的执行效率要高于非final方法，所以一个定义为private的方法隐式被指定为final类型"><a href="#将方法定义为final类型可以防止子类修改该类的定义与实现方式，同时定义为final的方法的执行效率要高于非final方法，所以一个定义为private的方法隐式被指定为final类型" class="headerlink" title="将方法定义为final类型可以防止子类修改该类的定义与实现方式，同时定义为final的方法的执行效率要高于非final方法，所以一个定义为private的方法隐式被指定为final类型"></a>将方法定义为final类型可以防止子类修改该类的定义与实现方式，同时定义为final的方法的执行效率要高于非final方法，所以一个定义为private的方法隐式被指定为final类型</h3><hr><hr><h2 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h2><h3 id="定义为final的类不能继承"><a href="#定义为final的类不能继承" class="headerlink" title="定义为final的类不能继承"></a>定义为final的类不能继承</h3><h3 id="如果希望一个类不允许任何类继承，并且不允许其他人对这个类进行任何改动，可以将这个类设置为final形式，则类中的所有方法都被隐式设置为final，但是final类中的成员变量可以被定义为final或非final形式"><a href="#如果希望一个类不允许任何类继承，并且不允许其他人对这个类进行任何改动，可以将这个类设置为final形式，则类中的所有方法都被隐式设置为final，但是final类中的成员变量可以被定义为final或非final形式" class="headerlink" title="如果希望一个类不允许任何类继承，并且不允许其他人对这个类进行任何改动，可以将这个类设置为final形式，则类中的所有方法都被隐式设置为final，但是final类中的成员变量可以被定义为final或非final形式"></a>如果希望一个类不允许任何类继承，并且不允许其他人对这个类进行任何改动，可以将这个类设置为final形式，则类中的所有方法都被隐式设置为final，但是final类中的成员变量可以被定义为final或非final形式</h3><hr><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类简介"><a href="#成员内部类简介" class="headerlink" title="成员内部类简介"></a>成员内部类简介</h3><h4 id="内部类可以分为成员内部类、局部内部类以及匿名类。"><a href="#内部类可以分为成员内部类、局部内部类以及匿名类。" class="headerlink" title="内部类可以分为成员内部类、局部内部类以及匿名类。"></a>内部类可以分为成员内部类、局部内部类以及匿名类。</h4><h4 id="在一个类中使用内部类，可以在内部类中直接存取其所在类的私有成员变量"><a href="#在一个类中使用内部类，可以在内部类中直接存取其所在类的私有成员变量" class="headerlink" title="在一个类中使用内部类，可以在内部类中直接存取其所在类的私有成员变量"></a>在一个类中使用内部类，可以在内部类中直接存取其所在类的私有成员变量</h4><h4 id="在内部类中可以随意使用外部类的成员方法以及成员变量，尽管这些类成员被修饰为private。"><a href="#在内部类中可以随意使用外部类的成员方法以及成员变量，尽管这些类成员被修饰为private。" class="headerlink" title="在内部类中可以随意使用外部类的成员方法以及成员变量，尽管这些类成员被修饰为private。"></a>在内部类中可以随意使用外部类的成员方法以及成员变量，尽管这些类成员被修饰为private。</h4><h4 id="内部类的实例一定要绑定在外部类的实例上，如果从外部类中初始化一个内部类对象，那么内部类对象就会绑定在外部类对象上。内部类初始化方式与其他类初始化方式相同，都是使用new关键字"><a href="#内部类的实例一定要绑定在外部类的实例上，如果从外部类中初始化一个内部类对象，那么内部类对象就会绑定在外部类对象上。内部类初始化方式与其他类初始化方式相同，都是使用new关键字" class="headerlink" title="内部类的实例一定要绑定在外部类的实例上，如果从外部类中初始化一个内部类对象，那么内部类对象就会绑定在外部类对象上。内部类初始化方式与其他类初始化方式相同，都是使用new关键字"></a>内部类的实例一定要绑定在外部类的实例上，如果从外部类中初始化一个内部类对象，那么内部类对象就会绑定在外部类对象上。内部类初始化方式与其他类初始化方式相同，都是使用new关键字</h4><h5 id="innerClass-in-new-innerClass-在外部类实例化内部类对象引用"><a href="#innerClass-in-new-innerClass-在外部类实例化内部类对象引用" class="headerlink" title="innerClass in = new innerClass();在外部类实例化内部类对象引用"></a>innerClass in = new innerClass();在外部类实例化内部类对象引用</h5><h5 id="外部类不可以直接访问内布类成员变量"><a href="#外部类不可以直接访问内布类成员变量" class="headerlink" title="外部类不可以直接访问内布类成员变量"></a>外部类不可以直接访问内布类成员变量</h5><h5 id="内部类的对象实例化操作必须在外部类或外部类的非静态方法中实现"><a href="#内部类的对象实例化操作必须在外部类或外部类的非静态方法中实现" class="headerlink" title="内部类的对象实例化操作必须在外部类或外部类的非静态方法中实现"></a>内部类的对象实例化操作必须在外部类或外部类的非静态方法中实现</h5><h4 id="内部类可以访问它的外部类成员，但内部类的成员只有在内部类的范围之内是可知的，不能被外部类使用"><a href="#内部类可以访问它的外部类成员，但内部类的成员只有在内部类的范围之内是可知的，不能被外部类使用" class="headerlink" title="内部类可以访问它的外部类成员，但内部类的成员只有在内部类的范围之内是可知的，不能被外部类使用"></a>内部类可以访问它的外部类成员，但内部类的成员只有在内部类的范围之内是可知的，不能被外部类使用</h4><h4 id="内部类对象与外部类对象关系非常紧密，内外可以交互使用彼此类中定义的变量"><a href="#内部类对象与外部类对象关系非常紧密，内外可以交互使用彼此类中定义的变量" class="headerlink" title="内部类对象与外部类对象关系非常紧密，内外可以交互使用彼此类中定义的变量"></a>内部类对象与外部类对象关系非常紧密，内外可以交互使用彼此类中定义的变量</h4><h4 id="如果在外部类和非静态方法之外实例化内部类对象，需要使用外部类。内部类的形式指定该对象的类型"><a href="#如果在外部类和非静态方法之外实例化内部类对象，需要使用外部类。内部类的形式指定该对象的类型" class="headerlink" title="如果在外部类和非静态方法之外实例化内部类对象，需要使用外部类。内部类的形式指定该对象的类型"></a>如果在外部类和非静态方法之外实例化内部类对象，需要使用外部类。内部类的形式指定该对象的类型</h4><h4 id="如果不使用doit-方法返回内部类对象引用，可以直接使用内部类实例化内部类对象，但由于是在主方法中实例化内部类对象，必须在new操作符之前提供一个外部类的引用。"><a href="#如果不使用doit-方法返回内部类对象引用，可以直接使用内部类实例化内部类对象，但由于是在主方法中实例化内部类对象，必须在new操作符之前提供一个外部类的引用。" class="headerlink" title="如果不使用doit()方法返回内部类对象引用，可以直接使用内部类实例化内部类对象，但由于是在主方法中实例化内部类对象，必须在new操作符之前提供一个外部类的引用。"></a>如果不使用doit()方法返回内部类对象引用，可以直接使用内部类实例化内部类对象，但由于是在主方法中实例化内部类对象，必须在new操作符之前提供一个外部类的引用。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">OuterClass.innerClass in = out.doit();</span><br><span class="line">OuterClass.innerClass in2 = out.<span class="function">new <span class="title">innerClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类对象会依赖于外部类对象，除非已经存在一个外部类对象，否则类中不会出现内部类对象"><a href="#内部类对象会依赖于外部类对象，除非已经存在一个外部类对象，否则类中不会出现内部类对象" class="headerlink" title="内部类对象会依赖于外部类对象，除非已经存在一个外部类对象，否则类中不会出现内部类对象"></a>内部类对象会依赖于外部类对象，除非已经存在一个外部类对象，否则类中不会出现内部类对象</h4><hr><h3 id="内部类向上转型为接口"><a href="#内部类向上转型为接口" class="headerlink" title="内部类向上转型为接口"></a>内部类向上转型为接口</h3><h4 id="如果将一个权限修饰符为private的内部类向上转型为其父类对象，或者直接向上转型为一个接口，在程序中就可以完全隐藏内部类的具体实现过程"><a href="#如果将一个权限修饰符为private的内部类向上转型为其父类对象，或者直接向上转型为一个接口，在程序中就可以完全隐藏内部类的具体实现过程" class="headerlink" title="如果将一个权限修饰符为private的内部类向上转型为其父类对象，或者直接向上转型为一个接口，在程序中就可以完全隐藏内部类的具体实现过程"></a>如果将一个权限修饰符为private的内部类向上转型为其父类对象，或者直接向上转型为一个接口，在程序中就可以完全隐藏内部类的具体实现过程</h4><h5 id="可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，"><a href="#可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，" class="headerlink" title="可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，"></a>可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，</h5><h5 id="就可以定义多个内部类以不同的方式实现接口中的同一个方法，而在一般的类中是不能多次实现接口中同一个方法的"><a href="#就可以定义多个内部类以不同的方式实现接口中的同一个方法，而在一般的类中是不能多次实现接口中同一个方法的" class="headerlink" title="就可以定义多个内部类以不同的方式实现接口中的同一个方法，而在一般的类中是不能多次实现接口中同一个方法的"></a>就可以定义多个内部类以不同的方式实现接口中的同一个方法，而在一般的类中是不能多次实现接口中同一个方法的</h5><h4 id="非内部类不能被声明为private或protected访问类型"><a href="#非内部类不能被声明为private或protected访问类型" class="headerlink" title="非内部类不能被声明为private或protected访问类型"></a>非内部类不能被声明为private或protected访问类型</h4><h3 id="使用this关键字获取内部类与外部类的引用"><a href="#使用this关键字获取内部类与外部类的引用" class="headerlink" title="使用this关键字获取内部类与外部类的引用"></a>使用this关键字获取内部类与外部类的引用</h3><h4 id="this：在外部类中定义的成员变量与内部类的成员变量名称相同"><a href="#this：在外部类中定义的成员变量与内部类的成员变量名称相同" class="headerlink" title="this：在外部类中定义的成员变量与内部类的成员变量名称相同"></a>this：在外部类中定义的成员变量与内部类的成员变量名称相同</h4><h4 id="this-x调用内部类的属性x，外部类名称-this-x调用外部类的属性x-即使用外部类名称后跟一个点操作符和this关键字便可获取外部类的一个引用"><a href="#this-x调用内部类的属性x，外部类名称-this-x调用外部类的属性x-即使用外部类名称后跟一个点操作符和this关键字便可获取外部类的一个引用" class="headerlink" title="this.x调用内部类的属性x，外部类名称.this.x调用外部类的属性x,即使用外部类名称后跟一个点操作符和this关键字便可获取外部类的一个引用"></a>this.x调用内部类的属性x，外部类名称.this.x调用外部类的属性x,即使用外部类名称后跟一个点操作符和this关键字便可获取外部类的一个引用</h4><h4 id="在内存中所有对象均被放置在堆中，方法以及方法中的形参或局部变量放置在栈中。"><a href="#在内存中所有对象均被放置在堆中，方法以及方法中的形参或局部变量放置在栈中。" class="headerlink" title="在内存中所有对象均被放置在堆中，方法以及方法中的形参或局部变量放置在栈中。"></a>在内存中所有对象均被放置在堆中，方法以及方法中的形参或局部变量放置在栈中。</h4><h4 id="内部类的对象与外部类的对象是相互依赖的，Outer-this对象指向外部类对象"><a href="#内部类的对象与外部类的对象是相互依赖的，Outer-this对象指向外部类对象" class="headerlink" title="内部类的对象与外部类的对象是相互依赖的，Outer.this对象指向外部类对象"></a>内部类的对象与外部类的对象是相互依赖的，Outer.this对象指向外部类对象</h4><hr><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><h4 id="内部类不仅可以在类中进行定义，也可以在类的局部位置定义，如在类的方法或任意的作用域中均可定义内部类"><a href="#内部类不仅可以在类中进行定义，也可以在类的局部位置定义，如在类的方法或任意的作用域中均可定义内部类" class="headerlink" title="内部类不仅可以在类中进行定义，也可以在类的局部位置定义，如在类的方法或任意的作用域中均可定义内部类"></a>内部类不仅可以在类中进行定义，也可以在类的局部位置定义，如在类的方法或任意的作用域中均可定义内部类</h4><h4 id="实质上这种内部类的作用就是创建一个实现于OutInterface2接口的匿名类的对象"><a href="#实质上这种内部类的作用就是创建一个实现于OutInterface2接口的匿名类的对象" class="headerlink" title="实质上这种内部类的作用就是创建一个实现于OutInterface2接口的匿名类的对象"></a>实质上这种内部类的作用就是创建一个实现于OutInterface2接口的匿名类的对象</h4><h5 id="由于匿名内部类没有名称，所有匿名内部类使用默认构造方法来生成OutInterface2对象。"><a href="#由于匿名内部类没有名称，所有匿名内部类使用默认构造方法来生成OutInterface2对象。" class="headerlink" title="由于匿名内部类没有名称，所有匿名内部类使用默认构造方法来生成OutInterface2对象。"></a>由于匿名内部类没有名称，所有匿名内部类使用默认构造方法来生成OutInterface2对象。</h5><h5 id="在匿名内部类定义结束后，需要加分号标识，这个分号并不是代表定义内部类结束的标识，而是代表创建OutInterface2引用表达式的标识"><a href="#在匿名内部类定义结束后，需要加分号标识，这个分号并不是代表定义内部类结束的标识，而是代表创建OutInterface2引用表达式的标识" class="headerlink" title="在匿名内部类定义结束后，需要加分号标识，这个分号并不是代表定义内部类结束的标识，而是代表创建OutInterface2引用表达式的标识"></a>在匿名内部类定义结束后，需要加分号标识，这个分号并不是代表定义内部类结束的标识，而是代表创建OutInterface2引用表达式的标识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> A()&#123;</span><br><span class="line">...<span class="comment">//内部类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="匿名内部类编译过后，会产生以“外部类名-序号”为名称的-class文件，序号以1-n排列，分别代表1-n个匿名内部类"><a href="#匿名内部类编译过后，会产生以“外部类名-序号”为名称的-class文件，序号以1-n排列，分别代表1-n个匿名内部类" class="headerlink" title="匿名内部类编译过后，会产生以“外部类名$序号”为名称的.class文件，序号以1-n排列，分别代表1-n个匿名内部类"></a>匿名内部类编译过后，会产生以“外部类名$序号”为名称的.class文件，序号以1-n排列，分别代表1-n个匿名内部类</h5><hr><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="一个静态内部类中可以声明static成员，但是在非静态内部类中不可以声明静态成员。"><a href="#一个静态内部类中可以声明static成员，但是在非静态内部类中不可以声明静态成员。" class="headerlink" title="一个静态内部类中可以声明static成员，但是在非静态内部类中不可以声明静态成员。"></a>一个静态内部类中可以声明static成员，但是在非静态内部类中不可以声明静态成员。</h4><h4 id="静态内部类最大的特点，就是不可以使用外部类的非静态成员，所以静态内部类在程序开发中比较少见"><a href="#静态内部类最大的特点，就是不可以使用外部类的非静态成员，所以静态内部类在程序开发中比较少见" class="headerlink" title="静态内部类最大的特点，就是不可以使用外部类的非静态成员，所以静态内部类在程序开发中比较少见"></a>静态内部类最大的特点，就是不可以使用外部类的非静态成员，所以静态内部类在程序开发中比较少见</h4><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><h5 id="如果创建静态内部类的对象，不需要其外部类的对象"><a href="#如果创建静态内部类的对象，不需要其外部类的对象" class="headerlink" title="如果创建静态内部类的对象，不需要其外部类的对象"></a>如果创建静态内部类的对象，不需要其外部类的对象</h5><h5 id="不能从静态内部类的对象中访问非静态外部类的对象"><a href="#不能从静态内部类的对象中访问非静态外部类的对象" class="headerlink" title="不能从静态内部类的对象中访问非静态外部类的对象"></a>不能从静态内部类的对象中访问非静态外部类的对象</h5><h4 id="进行程序测试时，如果在每一个Java文件中都设置一个主方法，将出现很多额外代码，而程序本身并不需要这些主方法，为了解决这个问题，可以将主方法写入静态内部类中"><a href="#进行程序测试时，如果在每一个Java文件中都设置一个主方法，将出现很多额外代码，而程序本身并不需要这些主方法，为了解决这个问题，可以将主方法写入静态内部类中" class="headerlink" title="进行程序测试时，如果在每一个Java文件中都设置一个主方法，将出现很多额外代码，而程序本身并不需要这些主方法，为了解决这个问题，可以将主方法写入静态内部类中"></a>进行程序测试时，如果在每一个Java文件中都设置一个主方法，将出现很多额外代码，而程序本身并不需要这些主方法，为了解决这个问题，可以将主方法写入静态内部类中</h4><h4 id="将生成一个名称为StaticInnerClass-Inner的独立类和一个StaticInnerClass类，只要使用java-StaticInnerClassInner-就可以运行主方法中的内容，这样当完成测试，需要将所有-class文件打包时，只要删除StaticInnerClassInner独立类即可"><a href="#将生成一个名称为StaticInnerClass-Inner的独立类和一个StaticInnerClass类，只要使用java-StaticInnerClassInner-就可以运行主方法中的内容，这样当完成测试，需要将所有-class文件打包时，只要删除StaticInnerClassInner独立类即可" class="headerlink" title="将生成一个名称为StaticInnerClass$Inner的独立类和一个StaticInnerClass类，只要使用java StaticInnerClassInner,就可以运行主方法中的内容，这样当完成测试，需要将所有.class文件打包时，只要删除StaticInnerClassInner独立类即可"></a>将生成一个名称为StaticInnerClass$Inner的独立类和一个StaticInnerClass类，只要使用java StaticInnerClassInner,就可以运行主方法中的内容，这样当完成测试，需要将所有.class文件打包时，只要删除StaticInnerClassInner独立类即可</h4><hr><h3 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h3><h4 id="内部类和其他普通类一样可以被继承，但是继承内部类比继承普通类复杂，需要设置专门的语法来完成"><a href="#内部类和其他普通类一样可以被继承，但是继承内部类比继承普通类复杂，需要设置专门的语法来完成" class="headerlink" title="内部类和其他普通类一样可以被继承，但是继承内部类比继承普通类复杂，需要设置专门的语法来完成"></a>内部类和其他普通类一样可以被继承，但是继承内部类比继承普通类复杂，需要设置专门的语法来完成</h4><h4 id="在某个类继承内部类时，必须硬性给予这个类一个带参数的构造方法，并且该构造方法的参数为需要继承内布列的外部类的引用，同时在构造方法体中使用a-super（）语句，这样才为继承提供了必要的对象引用"><a href="#在某个类继承内部类时，必须硬性给予这个类一个带参数的构造方法，并且该构造方法的参数为需要继承内布列的外部类的引用，同时在构造方法体中使用a-super（）语句，这样才为继承提供了必要的对象引用" class="headerlink" title="在某个类继承内部类时，必须硬性给予这个类一个带参数的构造方法，并且该构造方法的参数为需要继承内布列的外部类的引用，同时在构造方法体中使用a.super（）语句，这样才为继承提供了必要的对象引用"></a>在某个类继承内部类时，必须硬性给予这个类一个带参数的构造方法，并且该构造方法的参数为需要继承内布列的外部类的引用，同时在构造方法体中使用a.super（）语句，这样才为继承提供了必要的对象引用</h4><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试编写一个静态内部类，在主方法中创建其内部类的实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">StaticInnerClass.a a = <span class="keyword">new</span> a();</span><br><span class="line">a.f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试将主方法编写在静态内部类中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doitInner</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//不能调用x,静态内部类的最大特征就是不能使用外部类的非静态成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试在方法中编写一个匿名内部类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymityInnerClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass4</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> OutInterface <span class="title">doit</span><span class="params">(<span class="keyword">final</span> String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OutInterface()&#123;<span class="comment">//匿名内部类写在了外部类Outerclass4的方法中</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OutInterface</span> </span>&#123; <span class="comment">// 定义一个接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/17/java%E7%B1%BB%E5%BE%97%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java接口继承和多态</title>
      <link>http://example.com/2021/06/16/java%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</link>
      <guid>http://example.com/2021/06/16/java%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</guid>
      <pubDate>Wed, 16 Jun 2021 12:02:42 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;java接口继承和多态&quot;&gt;&lt;a href=&quot;#java接口继承和多态&quot; class=&quot;headerlink&quot; title=&quot;java接口继承和多态&quot;&gt;&lt;/a&gt;java接口继承和多态&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="java接口继承和多态"><a href="#java接口继承和多态" class="headerlink" title="java接口继承和多态"></a>java接口继承和多态</h1><span id="more"></span><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承在面向对象开发思想中是一个非常重要得概念，它使整个程序架构具有一定得弹性，-在程序中复用一些已经定义完善得类不仅可以减少软件开发周期，也可以提高软件得可维护性和可扩展性"><a href="#继承在面向对象开发思想中是一个非常重要得概念，它使整个程序架构具有一定得弹性，-在程序中复用一些已经定义完善得类不仅可以减少软件开发周期，也可以提高软件得可维护性和可扩展性" class="headerlink" title="继承在面向对象开发思想中是一个非常重要得概念，它使整个程序架构具有一定得弹性， 在程序中复用一些已经定义完善得类不仅可以减少软件开发周期，也可以提高软件得可维护性和可扩展性"></a>继承在面向对象开发思想中是一个非常重要得概念，它使整个程序架构具有一定得弹性， 在程序中复用一些已经定义完善得类不仅可以减少软件开发周期，也可以提高软件得可维护性和可扩展性</h2><h2 id="在子类中可以联通初始化父类的构造方法来完成子类初始化操作-既可以在子类的构造方法中使用super-语句调用父类的构造方法-也可以在子类中使用super关机纳兹调用父类的成员方法等"><a href="#在子类中可以联通初始化父类的构造方法来完成子类初始化操作-既可以在子类的构造方法中使用super-语句调用父类的构造方法-也可以在子类中使用super关机纳兹调用父类的成员方法等" class="headerlink" title="在子类中可以联通初始化父类的构造方法来完成子类初始化操作,既可以在子类的构造方法中使用super()语句调用父类的构造方法,也可以在子类中使用super关机纳兹调用父类的成员方法等"></a>在子类中可以联通初始化父类的构造方法来完成子类初始化操作,既可以在子类的构造方法中使用super()语句调用父类的构造方法,也可以在子类中使用super关机纳兹调用父类的成员方法等</h2><h2 id="但是子类没有权限调用父类中被修饰为private的方法-只可以调用父类中修饰为public或protected的成员方法"><a href="#但是子类没有权限调用父类中被修饰为private的方法-只可以调用父类中修饰为public或protected的成员方法" class="headerlink" title="但是子类没有权限调用父类中被修饰为private的方法,只可以调用父类中修饰为public或protected的成员方法"></a>但是子类没有权限调用父类中被修饰为private的方法,只可以调用父类中修饰为public或protected的成员方法</h2><h2 id="继承并不只是扩展父类的功能-还可以重写父类的成员方法-重写-还可以成为覆盖-就是在子类中将父类的成员方法的名称保留-重写成员方法的实现内容-更改成员方法的存储权限-或是修改成员方法的返回值类型-重写父类成员方法的返回值类型是基于j2se5-0版本以上编译器提供的新功能"><a href="#继承并不只是扩展父类的功能-还可以重写父类的成员方法-重写-还可以成为覆盖-就是在子类中将父类的成员方法的名称保留-重写成员方法的实现内容-更改成员方法的存储权限-或是修改成员方法的返回值类型-重写父类成员方法的返回值类型是基于j2se5-0版本以上编译器提供的新功能" class="headerlink" title="继承并不只是扩展父类的功能,还可以重写父类的成员方法.重写(还可以成为覆盖)就是在子类中将父类的成员方法的名称保留,重写成员方法的实现内容,更改成员方法的存储权限,或是修改成员方法的返回值类型(重写父类成员方法的返回值类型是基于j2se5.0版本以上编译器提供的新功能)"></a>继承并不只是扩展父类的功能,还可以重写父类的成员方法.重写(还可以成为覆盖)就是在子类中将父类的成员方法的名称保留,重写成员方法的实现内容,更改成员方法的存储权限,或是修改成员方法的返回值类型(重写父类成员方法的返回值类型是基于j2se5.0版本以上编译器提供的新功能)</h2><h2 id="在继承中还有一种特殊的重写方式-子类与父类的成员方法返回值-方法名称-参数类型及个数完全相同-唯一不同的是方法实现内容-这种特殊重写方式被称为重构"><a href="#在继承中还有一种特殊的重写方式-子类与父类的成员方法返回值-方法名称-参数类型及个数完全相同-唯一不同的是方法实现内容-这种特殊重写方式被称为重构" class="headerlink" title="在继承中还有一种特殊的重写方式,子类与父类的成员方法返回值,方法名称,参数类型及个数完全相同,唯一不同的是方法实现内容,这种特殊重写方式被称为重构."></a>在继承中还有一种特殊的重写方式,子类与父类的成员方法返回值,方法名称,参数类型及个数完全相同,唯一不同的是方法实现内容,这种特殊重写方式被称为重构.</h2><h2 id="当重写父类方法是-覆盖方法的修饰权限只能从小的范围到大的范围改变"><a href="#当重写父类方法是-覆盖方法的修饰权限只能从小的范围到大的范围改变" class="headerlink" title="当重写父类方法是,覆盖方法的修饰权限只能从小的范围到大的范围改变."></a>当重写父类方法是,覆盖方法的修饰权限只能从小的范围到大的范围改变.</h2><h2 id="在Java中一切都以对象的形式进行处理-在继承的机制中-创建一个子类对象-将包含一个父类子对象-这个对象与父类创建的对象是一样的-两者的区别在于后者来自于外部-而前者来自于子类对象的内部-当实例化子类对象时-父类对象也相应被实例化-换句话说-在实例化子类对象时-Java编译器会在子类的构造方法中自动调用父类的无参构造方法"><a href="#在Java中一切都以对象的形式进行处理-在继承的机制中-创建一个子类对象-将包含一个父类子对象-这个对象与父类创建的对象是一样的-两者的区别在于后者来自于外部-而前者来自于子类对象的内部-当实例化子类对象时-父类对象也相应被实例化-换句话说-在实例化子类对象时-Java编译器会在子类的构造方法中自动调用父类的无参构造方法" class="headerlink" title="在Java中一切都以对象的形式进行处理,在继承的机制中,创建一个子类对象,将包含一个父类子对象.这个对象与父类创建的对象是一样的.两者的区别在于后者来自于外部,而前者来自于子类对象的内部,当实例化子类对象时,父类对象也相应被实例化,换句话说,在实例化子类对象时,Java编译器会在子类的构造方法中自动调用父类的无参构造方法."></a>在Java中一切都以对象的形式进行处理,在继承的机制中,创建一个子类对象,将包含一个父类子对象.这个对象与父类创建的对象是一样的.两者的区别在于后者来自于外部,而前者来自于子类对象的内部,当实例化子类对象时,父类对象也相应被实例化,换句话说,在实例化子类对象时,Java编译器会在子类的构造方法中自动调用父类的无参构造方法.</h2><h2 id="实例化子类对象时首先要实例化父类对象-然后再实例化子类对象-所以在子类构造方法访问父类的构造方法之前-父类已经完成实例化操作"><a href="#实例化子类对象时首先要实例化父类对象-然后再实例化子类对象-所以在子类构造方法访问父类的构造方法之前-父类已经完成实例化操作" class="headerlink" title="实例化子类对象时首先要实例化父类对象,然后再实例化子类对象,所以在子类构造方法访问父类的构造方法之前,父类已经完成实例化操作."></a>实例化子类对象时首先要实例化父类对象,然后再实例化子类对象,所以在子类构造方法访问父类的构造方法之前,父类已经完成实例化操作.</h2><h2 id="在实例化子类对象时-父类无参构造方法将被自动调用-但有参构造方法并不能被自动调用-只能依赖于super关键字显式的调用父类的构造方法"><a href="#在实例化子类对象时-父类无参构造方法将被自动调用-但有参构造方法并不能被自动调用-只能依赖于super关键字显式的调用父类的构造方法" class="headerlink" title="在实例化子类对象时,父类无参构造方法将被自动调用,但有参构造方法并不能被自动调用,只能依赖于super关键字显式的调用父类的构造方法"></a>在实例化子类对象时,父类无参构造方法将被自动调用,但有参构造方法并不能被自动调用,只能依赖于super关键字显式的调用父类的构造方法</h2><h2 id="如果使用finalize-方法对对象进行清理-需要确保子类的finalize-方法的最后一个动作是调用父类的finalize-方法-以保证当垃圾回收对象占用内存时-对象的所有部分都能被正常终止"><a href="#如果使用finalize-方法对对象进行清理-需要确保子类的finalize-方法的最后一个动作是调用父类的finalize-方法-以保证当垃圾回收对象占用内存时-对象的所有部分都能被正常终止" class="headerlink" title="如果使用finalize()方法对对象进行清理,需要确保子类的finalize()方法的最后一个动作是调用父类的finalize()方法,以保证当垃圾回收对象占用内存时,对象的所有部分都能被正常终止."></a>如果使用finalize()方法对对象进行清理,需要确保子类的finalize()方法的最后一个动作是调用父类的finalize()方法,以保证当垃圾回收对象占用内存时,对象的所有部分都能被正常终止.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在项目中分别创建Test类和Test2类,在Test类中编写成员方法doSomething()和doIt(),使Test2类继承Test类,重写父类的这个两个方法和构造方法,并新增doSomethingnew()方法.其中Test2类的构造方法中使用supper关键字调用父类的构造方法和成员方法等.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;<span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">//成员方法</span></span><br><span class="line"><span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Test <span class="title">doIt</span><span class="params">()</span></span>&#123;<span class="comment">//方法返回值类型为Test类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Test</span></span>&#123;<span class="comment">//继承父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;<span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">super</span>();<span class="comment">//调用父类构造方法</span></span><br><span class="line">     <span class="keyword">super</span>.doSomething();<span class="comment">//调用父类的成员方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingnew</span><span class="params">()</span></span>&#123;<span class="comment">//新增方法</span></span><br><span class="line"><span class="comment">//SomeNewSentence</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">//重写父类方法</span></span><br><span class="line"><span class="comment">//SomeNewSentence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Test2 doIt&#123;<span class="comment">//重写父类方法,方法返回值类型为Test2类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Test2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在项目中创建Subroutime类和两个父类,分别为Parent和SubParent,这3个类的吧继承关系是Subrountine类继承Subroutine类继承SubParent类,而SubParent类继承Parent类.分别在这3个类的构造方法中输出构造方法名称,然后创建Subroutine类的实例对象,继承机制将使该类的父类对象自动初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">Parent()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用父类的Parent()构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubParent</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;<span class="comment">//继承Parent类</span></span><br><span class="line">SubParent()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用子类的SubParent()构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subroutine</span> <span class="keyword">extends</span> <span class="title">Subroutine</span></span>&#123;<span class="comment">//继承SubParent类</span></span><br><span class="line">Subroutine()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用子类的Subroutine()构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Subroutine s = <span class="keyword">new</span> Subroutine();<span class="comment">//实例化子类对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="因为所有类都直接或者间接得继承了java-lang-Object类，Object是所有类得父类，是Java类层的最高层类"><a href="#因为所有类都直接或者间接得继承了java-lang-Object类，Object是所有类得父类，是Java类层的最高层类" class="headerlink" title="因为所有类都直接或者间接得继承了java.lang.Object类，Object是所有类得父类，是Java类层的最高层类"></a>因为所有类都直接或者间接得继承了java.lang.Object类，Object是所有类得父类，是Java类层的最高层类</h2><h2 id="由于所有的类都是它的子类，所以就省略了继承Object"><a href="#由于所有的类都是它的子类，所以就省略了继承Object" class="headerlink" title="由于所有的类都是它的子类，所以就省略了继承Object"></a>由于所有的类都是它的子类，所以就省略了继承Object</h2><h2 id="在Object类中的clone-finalize-equals-toString-等方法，其中常用的是equals-toString-，任何类都可以重写Object中的方法"><a href="#在Object类中的clone-finalize-equals-toString-等方法，其中常用的是equals-toString-，任何类都可以重写Object中的方法" class="headerlink" title="在Object类中的clone(),finalize(),equals(),toString()等方法，其中常用的是equals(),toString()，任何类都可以重写Object中的方法"></a>在Object类中的clone(),finalize(),equals(),toString()等方法，其中常用的是equals(),toString()，任何类都可以重写Object中的方法</h2><h2 id="Object类中的getClass-notify-notifyAll-wait-等方法不能被重写，因为这些方法被定义为final类型"><a href="#Object类中的getClass-notify-notifyAll-wait-等方法不能被重写，因为这些方法被定义为final类型" class="headerlink" title="Object类中的getClass(),notify(),notifyAll(),wait()等方法不能被重写，因为这些方法被定义为final类型"></a>Object类中的getClass(),notify(),notifyAll(),wait()等方法不能被重写，因为这些方法被定义为final类型</h2><h2 id="以下是Object类中的几个重要方法"><a href="#以下是Object类中的几个重要方法" class="headerlink" title="以下是Object类中的几个重要方法"></a>以下是Object类中的几个重要方法</h2><h3 id="getClass-方法：是Object类定义的方法，它会返回对象执行时的Class实例，然后使用此实例调用getName-方法取得类的名称"><a href="#getClass-方法：是Object类定义的方法，它会返回对象执行时的Class实例，然后使用此实例调用getName-方法取得类的名称" class="headerlink" title="getClass()方法：是Object类定义的方法，它会返回对象执行时的Class实例，然后使用此实例调用getName()方法取得类的名称"></a>getClass()方法：是Object类定义的方法，它会返回对象执行时的Class实例，然后使用此实例调用getName()方法取得类的名称</h3><h4 id="可以将getClass-方法与toString-方法联合使用"><a href="#可以将getClass-方法与toString-方法联合使用" class="headerlink" title="可以将getClass()方法与toString()方法联合使用"></a>可以将getClass()方法与toString()方法联合使用</h4><h3 id="toString-方法：是将一个对象返回为字符串形式，它会返回一个String实例。在实际的应用中通常重写toString方法，为对象提供一个特定的输出模式。"><a href="#toString-方法：是将一个对象返回为字符串形式，它会返回一个String实例。在实际的应用中通常重写toString方法，为对象提供一个特定的输出模式。" class="headerlink" title="toString()方法：是将一个对象返回为字符串形式，它会返回一个String实例。在实际的应用中通常重写toString方法，为对象提供一个特定的输出模式。"></a>toString()方法：是将一个对象返回为字符串形式，它会返回一个String实例。在实际的应用中通常重写toString方法，为对象提供一个特定的输出模式。</h3><h4 id="当这个类转换为字符串与字符串连接时-将自动调用重写的toString-方法"><a href="#当这个类转换为字符串与字符串连接时-将自动调用重写的toString-方法" class="headerlink" title="当这个类转换为字符串与字符串连接时,将自动调用重写的toString()方法"></a>当这个类转换为字符串与字符串连接时,将自动调用重写的toString()方法</h4><h3 id="equals-方法：比较的是两个对象的实际内容-而-运算符比较的是两个对象的引用是否相等"><a href="#equals-方法：比较的是两个对象的实际内容-而-运算符比较的是两个对象的引用是否相等" class="headerlink" title="equals()方法：比较的是两个对象的实际内容(而==运算符比较的是两个对象的引用是否相等)"></a>equals()方法：比较的是两个对象的实际内容(而==运算符比较的是两个对象的引用是否相等)</h3><h4 id="要想真正做到比较两个对象的内容-需要在自定义类中重写equals-方法"><a href="#要想真正做到比较两个对象的内容-需要在自定义类中重写equals-方法" class="headerlink" title="要想真正做到比较两个对象的内容,需要在自定义类中重写equals()方法"></a>要想真正做到比较两个对象的内容,需要在自定义类中重写equals()方法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><hr><h1 id="对象类型的转换"><a href="#对象类型的转换" class="headerlink" title="对象类型的转换"></a>对象类型的转换</h1><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><h3 id="把子类对象赋值给父类类型的变量-这种技术被称为”向上转型”"><a href="#把子类对象赋值给父类类型的变量-这种技术被称为”向上转型”" class="headerlink" title="把子类对象赋值给父类类型的变量,这种技术被称为”向上转型”."></a>把子类对象赋值给父类类型的变量,这种技术被称为”向上转型”.</h3><h3 id="如果在四边形类的draw-方法中根据不同的图形对象设置不同的处理-就可以做到在父类中定义一个方法完成各个子类的功能-这样可以使同一份代码毫无差别地运用到不同类型上-这就是多态的基本思想"><a href="#如果在四边形类的draw-方法中根据不同的图形对象设置不同的处理-就可以做到在父类中定义一个方法完成各个子类的功能-这样可以使同一份代码毫无差别地运用到不同类型上-这就是多态的基本思想" class="headerlink" title="如果在四边形类的draw()方法中根据不同的图形对象设置不同的处理,就可以做到在父类中定义一个方法完成各个子类的功能,这样可以使同一份代码毫无差别地运用到不同类型上,这就是多态的基本思想."></a>如果在四边形类的draw()方法中根据不同的图形对象设置不同的处理,就可以做到在父类中定义一个方法完成各个子类的功能,这样可以使同一份代码毫无差别地运用到不同类型上,这就是多态的基本思想.</h3><h3 id="由于向上转型是从一个较具体的类到较抽象的类的转换，所以它总是安全的"><a href="#由于向上转型是从一个较具体的类到较抽象的类的转换，所以它总是安全的" class="headerlink" title="由于向上转型是从一个较具体的类到较抽象的类的转换，所以它总是安全的"></a>由于向上转型是从一个较具体的类到较抽象的类的转换，所以它总是安全的</h3><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><h3 id="向下转型是将较抽象类转换为较具体的类，这样的转换通常会出现问题"><a href="#向下转型是将较抽象类转换为较具体的类，这样的转换通常会出现问题" class="headerlink" title="向下转型是将较抽象类转换为较具体的类，这样的转换通常会出现问题"></a>向下转型是将较抽象类转换为较具体的类，这样的转换通常会出现问题</h3><h3 id="当在程序中使用向下转型技术时，必须使用显式类型转换，向编译器告知将父类对象转换为哪一类型的子类对象"><a href="#当在程序中使用向下转型技术时，必须使用显式类型转换，向编译器告知将父类对象转换为哪一类型的子类对象" class="headerlink" title="当在程序中使用向下转型技术时，必须使用显式类型转换，向编译器告知将父类对象转换为哪一类型的子类对象"></a>当在程序中使用向下转型技术时，必须使用显式类型转换，向编译器告知将父类对象转换为哪一类型的子类对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Quadrangle q)</span></span>&#123;</span><br><span class="line"><span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parallelogram</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">draw(<span class="keyword">new</span> Parallelogram());<span class="comment">//将平行四边形类对象看作是四边形对象,称为向上转型操作</span></span><br><span class="line">Quadrangle <span class="number">1</span> = <span class="keyword">new</span> Parallelogram();</span><br><span class="line"><span class="comment">//Parallelogram p = q;</span></span><br><span class="line"><span class="comment">//将父类对象赋予子类对象,这种写法是错误的</span></span><br><span class="line"><span class="comment">//将父类对象赋予子类对象,并强制转换为子类型,这种写法是正确的.</span></span><br><span class="line">Parallelogram p = (Parallelogram) q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="使用instanceof操作符判断对象的类型"><a href="#使用instanceof操作符判断对象的类型" class="headerlink" title="使用instanceof操作符判断对象的类型"></a>使用instanceof操作符判断对象的类型</h2><h3 id="当在程序中执行向下转型操作时，如果父类对象不是子类对象的实例，就会发生ClassCastException异常，所以在执行向下转型之前需要养成一个良好的习惯，就是判断父类对象是否为子类对象的实例"><a href="#当在程序中执行向下转型操作时，如果父类对象不是子类对象的实例，就会发生ClassCastException异常，所以在执行向下转型之前需要养成一个良好的习惯，就是判断父类对象是否为子类对象的实例" class="headerlink" title="当在程序中执行向下转型操作时，如果父类对象不是子类对象的实例，就会发生ClassCastException异常，所以在执行向下转型之前需要养成一个良好的习惯，就是判断父类对象是否为子类对象的实例"></a>当在程序中执行向下转型操作时，如果父类对象不是子类对象的实例，就会发生ClassCastException异常，所以在执行向下转型之前需要养成一个良好的习惯，就是判断父类对象是否为子类对象的实例</h3><h3 id="例-q-instanceof-Square-判断父类对象是否为Square子类的一个实例"><a href="#例-q-instanceof-Square-判断父类对象是否为Square子类的一个实例" class="headerlink" title="例:(q instanceof Square) 判断父类对象是否为Square子类的一个实例"></a>例:(q instanceof Square) 判断父类对象是否为Square子类的一个实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Quadrangle q)</span></span>&#123;</span><br><span class="line"><span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line">    <span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Anything</span></span>&#123;</span><br><span class="line">    <span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parallelogram</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">amin</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Quadrangle q = <span class="keyword">new</span> Quadrangle();<span class="comment">//实例化父类对象</span></span><br><span class="line">        <span class="comment">//判断父类对象是否为Parallelogram子类的一个实例</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> <span class="keyword">instanceof</span> Parallelogram)&#123;</span><br><span class="line">            Parallelogram p = (Parallelogram) q;<span class="comment">//向下转型操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断父类对象是否为Square子类的一个实例</span></span><br><span class="line">        <span class="keyword">if</span>(q <span class="keyword">instanceof</span> Square)&#123;</span><br><span class="line">            Square s = (Square) q;<span class="comment">//进行向下转型操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于q对象不为Anything类的对象,所以这条语句是错误的</span></span><br><span class="line">        <span class="comment">//System.out.println(q instanceof Anything);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><h2 id="由于这些构造方法都需要根据类名进行命名，为了让方法名相同而形参不同的构造方法同时存在，必须用到“方法重载”，虽然方法重载起源于构造方法，但是它也可以应用到其他方法中"><a href="#由于这些构造方法都需要根据类名进行命名，为了让方法名相同而形参不同的构造方法同时存在，必须用到“方法重载”，虽然方法重载起源于构造方法，但是它也可以应用到其他方法中" class="headerlink" title="由于这些构造方法都需要根据类名进行命名，为了让方法名相同而形参不同的构造方法同时存在，必须用到“方法重载”，虽然方法重载起源于构造方法，但是它也可以应用到其他方法中."></a>由于这些构造方法都需要根据类名进行命名，为了让方法名相同而形参不同的构造方法同时存在，必须用到“方法重载”，虽然方法重载起源于构造方法，但是它也可以应用到其他方法中.</h2><h2 id="方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要这些方法的参数个数或类型不同即可"><a href="#方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要这些方法的参数个数或类型不同即可" class="headerlink" title="方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要这些方法的参数个数或类型不同即可"></a>方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要这些方法的参数个数或类型不同即可</h2><h2 id="虽然在方法重载中可以使两个方法的返回类型不同，但只有返回类型不同并不足以区分两个方法的重载，还需要通过参数的个数，以及参数的类型来设置"><a href="#虽然在方法重载中可以使两个方法的返回类型不同，但只有返回类型不同并不足以区分两个方法的重载，还需要通过参数的个数，以及参数的类型来设置" class="headerlink" title="虽然在方法重载中可以使两个方法的返回类型不同，但只有返回类型不同并不足以区分两个方法的重载，还需要通过参数的个数，以及参数的类型来设置"></a>虽然在方法重载中可以使两个方法的返回类型不同，但只有返回类型不同并不足以区分两个方法的重载，还需要通过参数的个数，以及参数的类型来设置</h2><h2 id="构成方法重载的条件-可以总结出编译器是利用方法名-方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一"><a href="#构成方法重载的条件-可以总结出编译器是利用方法名-方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一" class="headerlink" title="构成方法重载的条件,可以总结出编译器是利用方法名,方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一."></a>构成方法重载的条件,可以总结出编译器是利用方法名,方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一.</h2><h2 id="不定长参数也可以作为重载方法"><a href="#不定长参数也可以作为重载方法" class="headerlink" title="不定长参数也可以作为重载方法"></a>不定长参数也可以作为重载方法</h2><h3 id="返回值-方法名-参数数据类型…参数名称"><a href="#返回值-方法名-参数数据类型…参数名称" class="headerlink" title="返回值 方法名(参数数据类型…参数名称)"></a>返回值 方法名(参数数据类型…参数名称)</h3><h4 id="在参数列表中使用”…”形式定义不定长参数a就是一个数组-编译器会将-int…a-这种形式看作是-int-a"><a href="#在参数列表中使用”…”形式定义不定长参数a就是一个数组-编译器会将-int…a-这种形式看作是-int-a" class="headerlink" title="在参数列表中使用”…”形式定义不定长参数a就是一个数组,编译器会将(int…a)这种形式看作是(int[]a)."></a>在参数列表中使用”…”形式定义不定长参数a就是一个数组,编译器会将(int…a)这种形式看作是(int[]a).</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在项目中创建OverLoadTest类,在类中编写add()方法的多个重载形式,然后再主方法中分别输出这些方法的返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义与第一个方法相同名称,参数类型不同的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法与前一个方法参数次序不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...a)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line"><span class="comment">//根据参数个数做循环操作</span></span><br><span class="line">s += a[i];<span class="comment">//将每个参数累加</span></span><br><span class="line"><span class="keyword">return</span> s;<span class="comment">//将计算结果返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用add(int,int)方法&quot;</span>+ add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;调用add(double,double)方法&quot;</span>+add(<span class="number">2.1</span>,<span class="number">3.3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;调用add(int)方法&quot;</span>+ add(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//调用不定长参数方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;调用不定长参数方法&quot;</span>+add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;调用不定长参数方法&quot;</span>+add(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="利用多态可以使程序具有良好的扩展性，并可以对所有类对象进行通用的处理"><a href="#利用多态可以使程序具有良好的扩展性，并可以对所有类对象进行通用的处理" class="headerlink" title="利用多态可以使程序具有良好的扩展性，并可以对所有类对象进行通用的处理"></a>利用多态可以使程序具有良好的扩展性，并可以对所有类对象进行通用的处理</h2><h2 id="使用多态节省了开发和维护的时间，因为程序无须在所有的子类中定义执行相同功能的方法，避免了大量重复代码的开发，同时只要实例化一个继承父类的子类对象即可调用相应的方法，这里只要维护父类中的这个方法即可"><a href="#使用多态节省了开发和维护的时间，因为程序无须在所有的子类中定义执行相同功能的方法，避免了大量重复代码的开发，同时只要实例化一个继承父类的子类对象即可调用相应的方法，这里只要维护父类中的这个方法即可" class="headerlink" title="使用多态节省了开发和维护的时间，因为程序无须在所有的子类中定义执行相同功能的方法，避免了大量重复代码的开发，同时只要实例化一个继承父类的子类对象即可调用相应的方法，这里只要维护父类中的这个方法即可"></a>使用多态节省了开发和维护的时间，因为程序无须在所有的子类中定义执行相同功能的方法，避免了大量重复代码的开发，同时只要实例化一个继承父类的子类对象即可调用相应的方法，这里只要维护父类中的这个方法即可</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Quadrangle类,再分别创建两个内部类Square和Parallelogramgle,它们都继承了Quadrangle类,编写draw()方法,该方法接受Quadrangle类的对象作为参数,即使用这两个内部类的父类作为方法参数,再主方法中分别以两个内部类的实例对象作为参数执行draw()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Quadrangle[] qtest = <span class="keyword">new</span> Quadrangle[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Quadrangle q)</span></span>&#123;<span class="comment">//定义draw()方法,参数为四边形对象</span></span><br><span class="line"><span class="keyword">if</span>(nextIndex &lt; qtest.length)&#123;</span><br><span class="line">qtest[nextIndex] = q;</span><br><span class="line">System.out.println(nextIndex);</span><br><span class="line">nextIndex++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//实例化两个四边形对象,用于调用draw()方法</span></span><br><span class="line">Quadrangle q = <span class="keyword">new</span> Quadrangle();</span><br><span class="line">q.draw(<span class="keyword">new</span> Square());<span class="comment">//以正方形对象为参数调用draw方法</span></span><br><span class="line">q.draw(<span class="keyword">new</span> Parallelogramgle());<span class="comment">//以平行四边形对象为参数调用draw方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个正方形类,继承四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;正方形&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个平行四边形类,继承四边形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parallelogramgle</span> <span class="keyword">extends</span> <span class="title">Quadrangle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Parallelogramgle</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;平行四边形&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="在Java语言中设置抽象类不可以实例化对象"><a href="#在Java语言中设置抽象类不可以实例化对象" class="headerlink" title="在Java语言中设置抽象类不可以实例化对象"></a>在Java语言中设置抽象类不可以实例化对象</h3><h3 id="抽象方法没有方法体，这个方法本身没有任何意义，除非它被重写，而承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义"><a href="#抽象方法没有方法体，这个方法本身没有任何意义，除非它被重写，而承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义" class="headerlink" title="抽象方法没有方法体，这个方法本身没有任何意义，除非它被重写，而承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义"></a>抽象方法没有方法体，这个方法本身没有任何意义，除非它被重写，而承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义</h3><h3 id="有抽象方法就必须定义是抽象类"><a href="#有抽象方法就必须定义是抽象类" class="headerlink" title="有抽象方法就必须定义是抽象类"></a>有抽象方法就必须定义是抽象类</h3><h3 id="抽象类被继承后需要实现其中所有的抽象方法，也就是保证相同的方法名称、参数列表和相同返回值类型创建出非抽象方法，当然也可以是抽象方法。"><a href="#抽象类被继承后需要实现其中所有的抽象方法，也就是保证相同的方法名称、参数列表和相同返回值类型创建出非抽象方法，当然也可以是抽象方法。" class="headerlink" title="抽象类被继承后需要实现其中所有的抽象方法，也就是保证相同的方法名称、参数列表和相同返回值类型创建出非抽象方法，当然也可以是抽象方法。"></a>抽象类被继承后需要实现其中所有的抽象方法，也就是保证相同的方法名称、参数列表和相同返回值类型创建出非抽象方法，当然也可以是抽象方法。</h3><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h3><h4 id="接口是抽象类的延申，可以将它看作是纯粹的抽象类，接口中的所有方法都没有方法体"><a href="#接口是抽象类的延申，可以将它看作是纯粹的抽象类，接口中的所有方法都没有方法体" class="headerlink" title="接口是抽象类的延申，可以将它看作是纯粹的抽象类，接口中的所有方法都没有方法体."></a>接口是抽象类的延申，可以将它看作是纯粹的抽象类，接口中的所有方法都没有方法体.</h4><h4 id="在接口中定义的方法必须被定义为public或者abstract形式，其他修饰权限不被Java编译器认可，即使不将该方法声明为public形式，它也是public"><a href="#在接口中定义的方法必须被定义为public或者abstract形式，其他修饰权限不被Java编译器认可，即使不将该方法声明为public形式，它也是public" class="headerlink" title="在接口中定义的方法必须被定义为public或者abstract形式，其他修饰权限不被Java编译器认可，即使不将该方法声明为public形式，它也是public"></a>在接口中定义的方法必须被定义为public或者abstract形式，其他修饰权限不被Java编译器认可，即使不将该方法声明为public形式，它也是public</h4><h4 id="在接口中定义的任何字段都自动是static和final的"><a href="#在接口中定义的任何字段都自动是static和final的" class="headerlink" title="在接口中定义的任何字段都自动是static和final的"></a>在接口中定义的任何字段都自动是static和final的</h4><h4 id="其实在Java中无论是将一个类向上转型为父类对象-还是向上转型为抽象父类对象-或者向上转型为该类实现接口-都是没有问题的"><a href="#其实在Java中无论是将一个类向上转型为父类对象-还是向上转型为抽象父类对象-或者向上转型为该类实现接口-都是没有问题的" class="headerlink" title="其实在Java中无论是将一个类向上转型为父类对象,还是向上转型为抽象父类对象,或者向上转型为该类实现接口,都是没有问题的."></a>其实在Java中无论是将一个类向上转型为父类对象,还是向上转型为抽象父类对象,或者向上转型为该类实现接口,都是没有问题的.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">drawTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义平行四边形类,该类继承了四边形类,并实现了drawTest接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParallelogramgleUseInterfece</span> <span class="keyword">extends</span> <span class="title">QuadrangleUseInterface</span> <span class="keyword">implements</span> <span class="title">drawTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;<span class="comment">//由于该类实现了接口,所以需要覆盖draw()方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;平行四边形.draw()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span></span>&#123;<span class="comment">//覆盖父类方法</span></span><br><span class="line"><span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareUseInterface</span> <span class="keyword">extends</span> <span class="title">QuadrangleUseInterface</span> <span class="keyword">implements</span> <span class="title">drawTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;正方形.draw()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyThingUseInterface</span> <span class="keyword">extends</span> <span class="title">QuadrangleUseInterface</span></span>&#123;<span class="comment">//定义四边形类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//SomeSentence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">drawTest[] d = &#123;<span class="comment">//接口也可以进行向上转型</span></span><br><span class="line"><span class="keyword">new</span> SquareUseInterface(),<span class="keyword">new</span> ParallelogramgleUseInterface()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.length;i++)&#123;</span><br><span class="line">d[i].draw();<span class="comment">//调用draw()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h3><h4 id="我们知道在Java中不允许多重继承-但使用接口就可以实现多重继承-因为一个类可以同时实现多个接口-这样可以将所有需要继承的接口放置在implements关键字后并使用都好隔开-但这可能会在一个类中产生庞大的代码量-因为继承一个接口时需要实现接口中所有的方法"><a href="#我们知道在Java中不允许多重继承-但使用接口就可以实现多重继承-因为一个类可以同时实现多个接口-这样可以将所有需要继承的接口放置在implements关键字后并使用都好隔开-但这可能会在一个类中产生庞大的代码量-因为继承一个接口时需要实现接口中所有的方法" class="headerlink" title="我们知道在Java中不允许多重继承,但使用接口就可以实现多重继承,因为一个类可以同时实现多个接口,这样可以将所有需要继承的接口放置在implements关键字后并使用都好隔开,但这可能会在一个类中产生庞大的代码量,因为继承一个接口时需要实现接口中所有的方法."></a>我们知道在Java中不允许多重继承,但使用接口就可以实现多重继承,因为一个类可以同时实现多个接口,这样可以将所有需要继承的接口放置在implements关键字后并使用都好隔开,但这可能会在一个类中产生庞大的代码量,因为继承一个接口时需要实现接口中所有的方法.</h4><hr><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个抽象类，验证它是否可以实例化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCase3</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">new</span> UseCase3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试创建一个父类，在父类中创建两个方法，在子类中覆盖第二个方法，为子类创建一个对象，将它向上转型到基类并调用这个方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCase2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类.doSomething()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类.doAnything()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        UseCase2 u=<span class="keyword">new</span> sub();</span><br><span class="line">        u.doSomething();</span><br><span class="line">        u.doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sub</span> <span class="keyword">extends</span> <span class="title">UseCase2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类.doAnything()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试创建一个父类和子类，分别创建一个构造方法，然后向父类和子类添加成员变量和方法，并总结构造子类对象时的顺序。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCase1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">testAbstract</span><span class="params">()</span></span>;</span><br><span class="line">    UseCase1()&#123;<span class="comment">//（1）首先执行父类构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before testAbstract()&quot;</span>);</span><br><span class="line">        testAbstract();<span class="comment">//如果调用了抽象方法，调用子类覆盖的方法。这里调用Atest类的testAbstract（）方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after testAbstarcat()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Atest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Atest</span> <span class="keyword">extends</span> <span class="title">UseCase1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//（2）使成员变量进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAbstract</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testAbstract()&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Atest</span><span class="params">()</span></span>&#123;<span class="comment">//（3）调用子类构造方法</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/16/java%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MyBatis</title>
      <link>http://example.com/2021/06/16/MyBatis/</link>
      <guid>http://example.com/2021/06/16/MyBatis/</guid>
      <pubDate>Wed, 16 Jun 2021 05:45:43 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;MyBatis&quot;&gt;&lt;a href=&quot;#MyBatis&quot; class=&quot;headerlink&quot; title=&quot;MyBatis&quot;&gt;&lt;/a&gt;MyBatis&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="什么是mybatis"><a href="#什么是mybatis" class="headerlink" title="什么是mybatis:"></a>什么是mybatis:</h2><h3 id="MyBatis-是一款优秀的持久层框架，它支持自定义-SQL、存储过程以及高级映射。MyBatis-免除了几乎所有的-JDBC-代码以及设置参数和获取结果集的工作。MyBatis-可以通过简单的-XML-或注解来配置和映射原始类型、接口和-Java-POJO（Plain-Old-Java-Objects，普通老式-Java-对象）为数据库中的记录。"><a href="#MyBatis-是一款优秀的持久层框架，它支持自定义-SQL、存储过程以及高级映射。MyBatis-免除了几乎所有的-JDBC-代码以及设置参数和获取结果集的工作。MyBatis-可以通过简单的-XML-或注解来配置和映射原始类型、接口和-Java-POJO（Plain-Old-Java-Objects，普通老式-Java-对象）为数据库中的记录。" class="headerlink" title="MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。"></a>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</h3><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="数据持久化："><a href="#数据持久化：" class="headerlink" title="数据持久化："></a>数据持久化：</h3><h4 id="持久化就是将程序的数据在持久状态和瞬时状态转化的过程。"><a href="#持久化就是将程序的数据在持久状态和瞬时状态转化的过程。" class="headerlink" title="持久化就是将程序的数据在持久状态和瞬时状态转化的过程。"></a>持久化就是将程序的数据在持久状态和瞬时状态转化的过程。</h4><h4 id="内存：断电即失"><a href="#内存：断电即失" class="headerlink" title="内存：断电即失"></a>内存：断电即失</h4><h4 id="数据库，io文件持久化"><a href="#数据库，io文件持久化" class="headerlink" title="数据库，io文件持久化"></a>数据库，io文件持久化</h4><h2 id="持久层："><a href="#持久层：" class="headerlink" title="持久层："></a>持久层：</h2><h3 id="Dao层，Service层，Controller层"><a href="#Dao层，Service层，Controller层" class="headerlink" title="Dao层，Service层，Controller层"></a>Dao层，Service层，Controller层</h3><h3 id="完成持久化工作的代码块"><a href="#完成持久化工作的代码块" class="headerlink" title="完成持久化工作的代码块"></a>完成持久化工作的代码块</h3><h3 id="层界限十分明显"><a href="#层界限十分明显" class="headerlink" title="层界限十分明显"></a>层界限十分明显</h3><h2 id="为什么需要Mybatis"><a href="#为什么需要Mybatis" class="headerlink" title="为什么需要Mybatis"></a>为什么需要Mybatis</h2><h3 id="帮助程序员将数据存入相应的数据库"><a href="#帮助程序员将数据存入相应的数据库" class="headerlink" title="帮助程序员将数据存入相应的数据库"></a>帮助程序员将数据存入相应的数据库</h3><h3 id="方便，简化，框架，自动化"><a href="#方便，简化，框架，自动化" class="headerlink" title="方便，简化，框架，自动化"></a>方便，简化，框架，自动化</h3><hr><hr><h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h2 id="导入mybatis"><a href="#导入mybatis" class="headerlink" title="导入mybatis"></a>导入mybatis</h2><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--pom.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><h3 id="编写核心配置文件"><a href="#编写核心配置文件" class="headerlink" title="编写核心配置文件"></a>编写核心配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在src/resource下建立mybatis-config.xml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/zheng/dao/UserMapper.xml&quot;</span>/&gt;</span><span class="comment">&lt;!--绑定异常的原因--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写工具类"><a href="#编写工具类" class="headerlink" title="编写工具类"></a>编写工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zheng.utils.Mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.corba.se.impl.orbutil.ObjectUtility;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"><span class="comment">//编写mybatis工具类</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">             sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">package</span> com.zheng.pojo;</span><br><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id,String name,String pwd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPwd</span><span class="params">(String pwd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span>+id+<span class="string">&quot;,name=&#x27;&quot;</span>+name+<span class="string">&#x27;\&#x27;&#x27;</span>+<span class="string">&quot;,pwd=&#x27;&quot;</span>+pwd+<span class="string">&#x27;\&#x27;&#x27;</span>+<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dao接口</span></span><br><span class="line"><span class="keyword">package</span> com.zheng.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zheng.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入用户</span></span><br><span class="line">    <span class="comment">//int addUser(User user);</span></span><br><span class="line">    <span class="comment">//万能的MAp</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int updateUser(User user);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int deleteUser(int id);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--接口实现类--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zheng.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.zheng.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.zheng.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;com.zheng.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        insert into user (id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        insert into user (id,name,pwd) values(#&#123;userid&#125;,#&#123;username&#125;,#&#123;userpwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.zheng.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        update USER</span><br><span class="line">        set name = #&#123;name&#125;,pwd=#&#123;pwd&#125;</span><br><span class="line">        where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zheng.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zheng.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.zheng.utils.Mybatis.MybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一步：获得SQlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        <span class="comment">//方式一：getMapper</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">           List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">               System.out.println(user);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;<span class="comment">//必须关闭</span></span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User user = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line"><span class="comment">//    public void addUser()&#123;</span></span><br><span class="line"><span class="comment">//        SqlSession sqlSession = MybatisUtils.getSqlSession();</span></span><br><span class="line"><span class="comment">//        //获得接口</span></span><br><span class="line"><span class="comment">//        UserMapper mapper =sqlSession.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">//        mapper.addUser(new User(8,&quot;张磊&quot;,&quot;123456&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //提交事务（增删改必须提交事务）</span></span><br><span class="line"><span class="comment">//        sqlSession.commit();</span></span><br><span class="line"><span class="comment">//        sqlSession.close();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//万能Map</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        <span class="comment">//获得接口</span></span><br><span class="line">        UserMapper mapper =sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;userid&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;罗晓&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;userpwd&quot;</span>,<span class="string">&quot;111222&quot;</span>);</span><br><span class="line">        mapper.addUser2(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交事务（增删改必须提交事务）</span></span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line"><span class="comment">//    public void updateUser()&#123;</span></span><br><span class="line"><span class="comment">//        SqlSession sqlSession = MybatisUtils.getSqlSession();</span></span><br><span class="line"><span class="comment">//        UserMapper mapper =sqlSession.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">//        mapper.updateUser(new User(5,&quot;刘科&quot;,&quot;123456&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //提交事务（增删改必须提交事务）</span></span><br><span class="line"><span class="comment">//        sqlSession.commit();</span></span><br><span class="line"><span class="comment">//        sqlSession.close();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line"><span class="comment">//    public void deleteUser()&#123;</span></span><br><span class="line"><span class="comment">//        SqlSession sqlSession = MybatisUtils.getSqlSession();</span></span><br><span class="line"><span class="comment">//        UserMapper mapper =sqlSession.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">//        mapper.deleteUser(6);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //提交事务（增删改必须提交事务）</span></span><br><span class="line"><span class="comment">//        sqlSession.commit();</span></span><br><span class="line"><span class="comment">//        sqlSession.close();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意-maven由于他的约定大于配置-之后肯定会遇到写的配置文件无法生效或者导出的问题"><a href="#注意-maven由于他的约定大于配置-之后肯定会遇到写的配置文件无法生效或者导出的问题" class="headerlink" title="注意:maven由于他的约定大于配置,之后肯定会遇到写的配置文件无法生效或者导出的问题"></a>注意:maven由于他的约定大于配置,之后肯定会遇到写的配置文件无法生效或者导出的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">      &lt;includes&gt;</span><br><span class="line">        &lt;include&gt;**<span class="comment">/*.properties&lt;/include&gt;</span></span><br><span class="line"><span class="comment">        &lt;include&gt;**/</span>*.xml&lt;/include&gt;</span><br><span class="line">      &lt;/includes&gt;</span><br><span class="line">      &lt;filtering&gt;<span class="keyword">true</span>&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">      &lt;includes&gt;</span><br><span class="line">        &lt;include&gt;**<span class="comment">/*.properties&lt;/include&gt;</span></span><br><span class="line"><span class="comment">        &lt;include&gt;**/</span>*.xml&lt;/include&gt;</span><br><span class="line">      &lt;/includes&gt;</span><br><span class="line">      &lt;filtering&gt;<span class="keyword">true</span>&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">  &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SqlSession的实例不是线程安全的,因此是不能被共享的,所以他的最佳作用域是请求或方法作用域.绝对不能将SqlSession实例的引用放在一个类的静态域,甚至一个类的实例变量也不行,也绝不能将SqlSession实例的引用放在任何类型的托管作用域中,比如Servlet框架中的HttpSession,如果你现在正在使用一种Web框架,要考虑SqlSession放在一个和HTTP请求对象相似的作用域中，</span></span><br><span class="line"><span class="comment">//换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它，这个关闭是至关重要的，可以把它放在finally块中.</span></span><br><span class="line"><span class="comment">//namespace中的包名要跟Dao/mapper接口中的包名一致</span></span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>select:选择,查询</span><br><span class="line"><span class="regexp">//i</span>d 就是对应namespace中的方法名</span><br><span class="line"><span class="regexp">//</span>resultType:Sql语句执行返回值</span><br><span class="line"><span class="regexp">//</span>parameterType:参数类型</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="实体表-或者数据库中的表-字段或者参数较多-可以考虑使用Map"><a href="#实体表-或者数据库中的表-字段或者参数较多-可以考虑使用Map" class="headerlink" title="实体表,或者数据库中的表,字段或者参数较多,可以考虑使用Map"></a>实体表,或者数据库中的表,字段或者参数较多,可以考虑使用Map</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--接口实现类--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对象中的属性,可以直接取出来 传递map的key--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        insert into user (id,pwd) values(#&#123;userid&#125;,#&#123;password&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="int-addUser2-Map-lt-String-object-gt-map"><a href="#int-addUser2-Map-lt-String-object-gt-map" class="headerlink" title="int addUser2(Map&lt;String,object&gt; map);"></a><code>int addUser2(Map&lt;String,object&gt; map);</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">Map&lt;String,object&gt; map = <span class="keyword">new</span> HashMap&lt;String,object&gt;();</span><br><span class="line">map.put(<span class="string">&quot;userid&quot;</span>,<span class="number">5</span>);</span><br><span class="line">map.put(<span class="string">&quot;password&quot;</span>,<span class="number">222333</span>);</span><br><span class="line">mapper.addUser2(map);</span><br><span class="line">sqlsession.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Map传递参数,直接再sql取出key即可 parameterType=&quot;map&quot;</span></span><br><span class="line"><span class="comment">//对象传递参数,直接在sql中取对象的属性即可 parameterType=&quot;Object&quot;</span></span><br><span class="line"><span class="comment">//只有一个基本类型参数的情况下,可以直接在sql中取到,</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserLike</span><span class="params">(String value)</span></span>;<span class="comment">//接口</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--接口实现类--&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;getUserLike&quot;</span> resultType=<span class="string">&quot;com.zheng.pojo.User&quot;</span>&gt;</span><br><span class="line">select * from mybatis.user where name like #&#123;value&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserLike</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; userList = mapper.getUserList(<span class="string">&quot;%李%&quot;</span>);<span class="comment">//得加通配符</span></span><br><span class="line"><span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h1><h2 id="环境配置-environments"><a href="#环境配置-environments" class="headerlink" title="环境配置(environments)"></a>环境配置(environments)</h2><h3 id="Mybatis可以配置成适应多种环境"><a href="#Mybatis可以配置成适应多种环境" class="headerlink" title="Mybatis可以配置成适应多种环境"></a>Mybatis可以配置成适应多种环境</h3><h3 id="但每个SqlSessionFactory实例只能选择一种环境"><a href="#但每个SqlSessionFactory实例只能选择一种环境" class="headerlink" title="但每个SqlSessionFactory实例只能选择一种环境"></a>但每个SqlSessionFactory实例只能选择一种环境</h3><h3 id="学会使用配置多套运行环境"><a href="#学会使用配置多套运行环境" class="headerlink" title="学会使用配置多套运行环境"></a>学会使用配置多套运行环境</h3><h3 id="Mybatis默认得事物管理器就是JDBC-连接池-POOLED"><a href="#Mybatis默认得事物管理器就是JDBC-连接池-POOLED" class="headerlink" title="Mybatis默认得事物管理器就是JDBC,连接池:POOLED"></a>Mybatis默认得事物管理器就是JDBC,连接池:POOLED</h3><h2 id="属性-properties"><a href="#属性-properties" class="headerlink" title="属性(properties)"></a>属性(properties)</h2><h3 id="可以通过properties属性来实现引用配置文件"><a href="#可以通过properties属性来实现引用配置文件" class="headerlink" title="可以通过properties属性来实现引用配置文件"></a>可以通过properties属性来实现引用配置文件</h3><h3 id="这些属性都是可外部配置并可动态替换的-既可以在典型得java属性文件中配置-亦可通过properties元素得子元素来传递"><a href="#这些属性都是可外部配置并可动态替换的-既可以在典型得java属性文件中配置-亦可通过properties元素得子元素来传递" class="headerlink" title="这些属性都是可外部配置并可动态替换的,既可以在典型得java属性文件中配置,亦可通过properties元素得子元素来传递"></a>这些属性都是可外部配置并可动态替换的,既可以在典型得java属性文件中配置,亦可通过properties元素得子元素来传递</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入外部配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志工厂,用其他日志改value就行了--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;settings&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &amp;lt;!&amp;ndash;标准日志&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &amp;lt;!&amp;ndash;&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--       &lt;setting name=&quot;logImpl&quot; value=&quot;Log4j&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/settings&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给实体类起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.zheng.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;package name=&quot;com.zheng.pojo&quot; /&gt;&amp;lt;!&amp;ndash;建议写小写，实体类多，不能DIY，user默认，有助解用注解&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        &lt;environment id=&quot;test&quot;&gt;&amp;lt;!&amp;ndash;第二套环境如果想用的话在default的默认中修改为test即可&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;transactionManager type=&quot;JDBC&quot;/&gt;&amp;lt;!&amp;ndash;事务管理器，还有一种managed&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;dataSource type=&quot;POOLED&quot;&gt;&amp;lt;!&amp;ndash;数据源:连接数据库 类型有三种UNPOOLED|POOLED|JNDI 池的意思是：用完可以回收&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;/dataSource&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/environment&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        映射器--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/zheng/dao/UserMapper.xml&quot;</span>/&gt;</span><span class="comment">&lt;!--绑定异常的原因--&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper class=&quot;com.zheng.dao.UserMapper&quot;/&gt;接口和配置文件必须同名同包--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器与类一样 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=com.mysql.cj.jdbc.Driver</span><br><span class="line"><span class="attr">jdbc.url</span>=jdbc:mysql://localhost:<span class="number">3306</span>/mybatis?serverTimezone=UTC</span><br><span class="line"><span class="attr">jdbc.username</span>=root</span><br><span class="line"><span class="attr">jdbc.password</span>=root</span><br></pre></td></tr></table></figure><h2 id="别名在实体类上可以写-Alias-“user”"><a href="#别名在实体类上可以写-Alias-“user”" class="headerlink" title="别名在实体类上可以写@Alias(“user”)"></a>别名在实体类上可以写@Alias(“user”)</h2><hr><hr><h1 id="解决属性名和字段名不一致得问题"><a href="#解决属性名和字段名不一致得问题" class="headerlink" title="解决属性名和字段名不一致得问题"></a>解决属性名和字段名不一致得问题</h1><h3 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h3><h3 id="结果集操作"><a href="#结果集操作" class="headerlink" title="结果集操作"></a>结果集操作</h3>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/SSM/">SSM</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/16/MyBatis/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java数字处理类</title>
      <link>http://example.com/2021/06/15/java%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E7%B1%BB/</link>
      <guid>http://example.com/2021/06/15/java%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E7%B1%BB/</guid>
      <pubDate>Tue, 15 Jun 2021 08:06:40 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;数字处理类&quot;&gt;&lt;a href=&quot;#数字处理类&quot; class=&quot;headerlink&quot; title=&quot;数字处理类&quot;&gt;&lt;/a&gt;数字处理类&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="数字处理类"><a href="#数字处理类" class="headerlink" title="数字处理类"></a>数字处理类</h1><span id="more"></span><h2 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="Java主要对浮点型数据进行数字格式化操作-其中浮点型数据包括double型和float型数据-在Java中使用java-text-DecimalFormat格式化数字"><a href="#Java主要对浮点型数据进行数字格式化操作-其中浮点型数据包括double型和float型数据-在Java中使用java-text-DecimalFormat格式化数字" class="headerlink" title="Java主要对浮点型数据进行数字格式化操作,其中浮点型数据包括double型和float型数据,在Java中使用java.text.DecimalFormat格式化数字."></a>Java主要对浮点型数据进行数字格式化操作,其中浮点型数据包括double型和float型数据,在Java中使用java.text.DecimalFormat格式化数字.</h4><h4 id="在Java中没有格式化的数据遵循以下原则"><a href="#在Java中没有格式化的数据遵循以下原则" class="headerlink" title="在Java中没有格式化的数据遵循以下原则"></a>在Java中没有格式化的数据遵循以下原则</h4><h5 id="如果数据绝对值大于0-001并且小于10000000，Java将以常规小数形式表示"><a href="#如果数据绝对值大于0-001并且小于10000000，Java将以常规小数形式表示" class="headerlink" title="如果数据绝对值大于0.001并且小于10000000，Java将以常规小数形式表示"></a>如果数据绝对值大于0.001并且小于10000000，Java将以常规小数形式表示</h5><h5 id="如果数据绝对值小于0-001或者大于10000000，使用科学计数法表示"><a href="#如果数据绝对值小于0-001或者大于10000000，使用科学计数法表示" class="headerlink" title="如果数据绝对值小于0.001或者大于10000000，使用科学计数法表示"></a>如果数据绝对值小于0.001或者大于10000000，使用科学计数法表示</h5><h3 id="介绍-DecimalFormat是NumberFormat的一个子类-用于格式化十进制数字-它可以将一些数字格式化为整数-浮点数-百分数等-通过使用该类可以为要输出的数字加上单位或控制数字的精度-一般情况下可以实例化DecimalFormat对象时传递数字格式-也可以通过DecimalFormat类中的applyPattern-方法来实现数字格式化"><a href="#介绍-DecimalFormat是NumberFormat的一个子类-用于格式化十进制数字-它可以将一些数字格式化为整数-浮点数-百分数等-通过使用该类可以为要输出的数字加上单位或控制数字的精度-一般情况下可以实例化DecimalFormat对象时传递数字格式-也可以通过DecimalFormat类中的applyPattern-方法来实现数字格式化" class="headerlink" title="介绍:DecimalFormat是NumberFormat的一个子类,用于格式化十进制数字,它可以将一些数字格式化为整数,浮点数,百分数等,通过使用该类可以为要输出的数字加上单位或控制数字的精度.一般情况下可以实例化DecimalFormat对象时传递数字格式,也可以通过DecimalFormat类中的applyPattern()方法来实现数字格式化"></a>介绍:DecimalFormat是NumberFormat的一个子类,用于格式化十进制数字,它可以将一些数字格式化为整数,浮点数,百分数等,通过使用该类可以为要输出的数字加上单位或控制数字的精度.一般情况下可以实例化DecimalFormat对象时传递数字格式,也可以通过DecimalFormat类中的applyPattern()方法来实现数字格式化</h3><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="当格式化数字时-在DecimalFormat类中使用一些特殊字符构成一个格式化模板-使数字按照一定的特殊的字符规则进行匹配"><a href="#当格式化数字时-在DecimalFormat类中使用一些特殊字符构成一个格式化模板-使数字按照一定的特殊的字符规则进行匹配" class="headerlink" title="当格式化数字时,在DecimalFormat类中使用一些特殊字符构成一个格式化模板,使数字按照一定的特殊的字符规则进行匹配."></a>当格式化数字时,在DecimalFormat类中使用一些特殊字符构成一个格式化模板,使数字按照一定的特殊的字符规则进行匹配.</h4><h4 id="特殊字符说明"><a href="#特殊字符说明" class="headerlink" title="特殊字符说明"></a>特殊字符说明</h4><h5 id="0-表示数字的一位阿拉伯数字，如果该位不存在数字，则显示0"><a href="#0-表示数字的一位阿拉伯数字，如果该位不存在数字，则显示0" class="headerlink" title="0:表示数字的一位阿拉伯数字，如果该位不存在数字，则显示0"></a>0:表示数字的一位阿拉伯数字，如果该位不存在数字，则显示0</h5><h5 id="表示数字的一位阿拉伯数字，如果该位存在数字，则显示字符；如果不存在则不显示"><a href="#表示数字的一位阿拉伯数字，如果该位存在数字，则显示字符；如果不存在则不显示" class="headerlink" title="#:表示数字的一位阿拉伯数字，如果该位存在数字，则显示字符；如果不存在则不显示"></a>#:表示数字的一位阿拉伯数字，如果该位存在数字，则显示字符；如果不存在则不显示</h5><h5 id="E-分割科学计数法中的尾数和指数"><a href="#E-分割科学计数法中的尾数和指数" class="headerlink" title="E:分割科学计数法中的尾数和指数"></a>E:分割科学计数法中的尾数和指数</h5><h5 id="放在数字前缀或后缀，将数字乘以100显示百分数"><a href="#放在数字前缀或后缀，将数字乘以100显示百分数" class="headerlink" title="%:放在数字前缀或后缀，将数字乘以100显示百分数"></a>%:放在数字前缀或后缀，将数字乘以100显示百分数</h5><h5 id="u2030-放在数字前缀或后缀，将数字乘以1000显示千分数"><a href="#u2030-放在数字前缀或后缀，将数字乘以1000显示千分数" class="headerlink" title="\u2030: 放在数字前缀或后缀，将数字乘以1000显示千分数"></a>\u2030: 放在数字前缀或后缀，将数字乘以1000显示千分数</h5><h5 id="u00A4-放在数字前缀或后缀，作为货币记号"><a href="#u00A4-放在数字前缀或后缀，作为货币记号" class="headerlink" title="\u00A4:放在数字前缀或后缀，作为货币记号"></a>\u00A4:放在数字前缀或后缀，作为货币记号</h5><h3 id="其他格式化方法"><a href="#其他格式化方法" class="headerlink" title="其他格式化方法"></a>其他格式化方法</h3><h4 id="除了可以设置格式化模式来格式化数字之外-还可以使用一些特殊方法对数字进行格式化设置"><a href="#除了可以设置格式化模式来格式化数字之外-还可以使用一些特殊方法对数字进行格式化设置" class="headerlink" title="除了可以设置格式化模式来格式化数字之外,还可以使用一些特殊方法对数字进行格式化设置"></a>除了可以设置格式化模式来格式化数字之外,还可以使用一些特殊方法对数字进行格式化设置</h4><h5 id="setGroupingSize-设置格式化数字的分组大小"><a href="#setGroupingSize-设置格式化数字的分组大小" class="headerlink" title="setGroupingSize()//设置格式化数字的分组大小"></a><code>setGroupingSize()</code>//设置格式化数字的分组大小</h5><h5 id="setGroupingUsed-设置是否可以对数字进行分组操作"><a href="#setGroupingUsed-设置是否可以对数字进行分组操作" class="headerlink" title="setGroupingUsed()//设置是否可以对数字进行分组操作"></a><code>setGroupingUsed()</code>//设置是否可以对数字进行分组操作</h5><hr><hr><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="在Math类中提供了众多数字函数方法-主要包括三角函数方法-指数函数方法-取整函数方法-取最大值-最小值以及平均值函数方法-这些方法都被定义为static形式-所以在程序中应用比较简便"><a href="#在Math类中提供了众多数字函数方法-主要包括三角函数方法-指数函数方法-取整函数方法-取最大值-最小值以及平均值函数方法-这些方法都被定义为static形式-所以在程序中应用比较简便" class="headerlink" title="在Math类中提供了众多数字函数方法,主要包括三角函数方法,指数函数方法,取整函数方法,取最大值,最小值以及平均值函数方法,这些方法都被定义为static形式,所以在程序中应用比较简便"></a>在Math类中提供了众多数字函数方法,主要包括三角函数方法,指数函数方法,取整函数方法,取最大值,最小值以及平均值函数方法,这些方法都被定义为static形式,所以在程序中应用比较简便</h4><h4 id="在Math类中除了函数方法之外还存在一些常用数字常量-如PI-E等"><a href="#在Math类中除了函数方法之外还存在一些常用数字常量-如PI-E等" class="headerlink" title="在Math类中除了函数方法之外还存在一些常用数字常量,如PI,E等."></a>在Math类中除了函数方法之外还存在一些常用数字常量,如PI,E等.</h4><h3 id="常用数字运算方法"><a href="#常用数字运算方法" class="headerlink" title="常用数字运算方法"></a>常用数字运算方法</h3><h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><h5 id="public-static-double-sin-double-a-返回角的三角正弦"><a href="#public-static-double-sin-double-a-返回角的三角正弦" class="headerlink" title="public static double sin(double a)//返回角的三角正弦"></a><code>public static double sin(double a)</code>//返回角的三角正弦</h5><h5 id="public-static-double-cos-double-a-返回角的三角余弦"><a href="#public-static-double-cos-double-a-返回角的三角余弦" class="headerlink" title="public static double cos(double a)//返回角的三角余弦"></a><code>public static double cos(double a)</code>//返回角的三角余弦</h5><h5 id="public-static-double-tan-double-a-返回角的三角正切"><a href="#public-static-double-tan-double-a-返回角的三角正切" class="headerlink" title="public static double tan(double a)//返回角的三角正切"></a><code>public static double tan(double a)</code>//返回角的三角正切</h5><h5 id="public-static-double-asin-double-a-返回一个值的三角反正弦"><a href="#public-static-double-asin-double-a-返回一个值的三角反正弦" class="headerlink" title="public static double asin(double a)//返回一个值的三角反正弦"></a><code>public static double asin(double a)</code>//返回一个值的三角反正弦</h5><h5 id="public-static-double-acos-double-a-返回一个值的三角反余弦"><a href="#public-static-double-acos-double-a-返回一个值的三角反余弦" class="headerlink" title="public static double acos(double a)//返回一个值的三角反余弦"></a><code>public static double acos(double a)</code>//返回一个值的三角反余弦</h5><h5 id="public-static-double-atan-double-a-返回一个值的三角反正切"><a href="#public-static-double-atan-double-a-返回一个值的三角反正切" class="headerlink" title="public static double atan(double a)//返回一个值的三角反正切"></a><code>public static double atan(double a)</code>//返回一个值的三角反正切</h5><h5 id="public-static-double-toRadians-double-angdeg-将角度转换为弧度"><a href="#public-static-double-toRadians-double-angdeg-将角度转换为弧度" class="headerlink" title="public static double toRadians(double angdeg)//将角度转换为弧度"></a><code>public static double toRadians(double angdeg)</code>//将角度转换为弧度</h5><h5 id="public-static-double-toDegrees-double-angrad-将弧度转换成角度"><a href="#public-static-double-toDegrees-double-angrad-将弧度转换成角度" class="headerlink" title="public static double toDegrees(double angrad)//将弧度转换成角度"></a><code>public static double toDegrees(double angrad)</code>//将弧度转换成角度</h5><h5 id="以上的参数和返回值都是double型的"><a href="#以上的参数和返回值都是double型的" class="headerlink" title="以上的参数和返回值都是double型的"></a>以上的参数和返回值都是double型的</h5><h5 id="参数都是以弧度代替角度实现的-其中1°等于Π-180弧度"><a href="#参数都是以弧度代替角度实现的-其中1°等于Π-180弧度" class="headerlink" title="参数都是以弧度代替角度实现的,其中1°等于Π/180弧度"></a>参数都是以弧度代替角度实现的,其中1°等于Π/180弧度</h5><h5 id="Math类还提供了角度和弧度相互转换的反复噶toRadians-和toDegress-但需要注意的是-角度和弧度的转换通常是不精确的"><a href="#Math类还提供了角度和弧度相互转换的反复噶toRadians-和toDegress-但需要注意的是-角度和弧度的转换通常是不精确的" class="headerlink" title="Math类还提供了角度和弧度相互转换的反复噶toRadians()和toDegress(),但需要注意的是,角度和弧度的转换通常是不精确的."></a>Math类还提供了角度和弧度相互转换的反复噶toRadians()和toDegress(),但需要注意的是,角度和弧度的转换通常是不精确的.</h5><h4 id="指数函数方法"><a href="#指数函数方法" class="headerlink" title="指数函数方法"></a>指数函数方法</h4><h5 id="public-static-double-exp-double-a-用于获取e的a次方"><a href="#public-static-double-exp-double-a-用于获取e的a次方" class="headerlink" title="public static double exp(double a)//用于获取e的a次方"></a><code>public static double exp(double a)</code>//用于获取e的a次方</h5><h5 id="public-static-double-log-double-a-用于取自然对数-即取lna的值"><a href="#public-static-double-log-double-a-用于取自然对数-即取lna的值" class="headerlink" title="public static double log(double a)//用于取自然对数,即取lna的值"></a><code>public static double log(double a)</code>//用于取自然对数,即取lna的值</h5><h5 id="public-static-double-log10-double-a-用于取底数为10的对数"><a href="#public-static-double-log10-double-a-用于取底数为10的对数" class="headerlink" title="public static double log10(double a)//用于取底数为10的对数"></a><code>public static double log10(double a)</code>//用于取底数为10的对数</h5><h5 id="public-static-double-sqrt-double-a-用于取a的平方根-其中a的值不能为负值"><a href="#public-static-double-sqrt-double-a-用于取a的平方根-其中a的值不能为负值" class="headerlink" title="public static double sqrt(double a)//用于取a的平方根,其中a的值不能为负值"></a><code>public static double sqrt(double a)</code>//用于取a的平方根,其中a的值不能为负值</h5><h5 id="public-static-double-cbrt-double-a-用于取a的立方根"><a href="#public-static-double-cbrt-double-a-用于取a的立方根" class="headerlink" title="public static double cbrt(double a)//用于取a的立方根"></a><code>public static double cbrt(double a)</code>//用于取a的立方根</h5><h5 id="public-static-double-pow-double-a-double-b-用于取a的b次方"><a href="#public-static-double-pow-double-a-double-b-用于取a的b次方" class="headerlink" title="public static double pow(double a,double b)//用于取a的b次方"></a><code>public static double pow(double a,double b)</code>//用于取a的b次方</h5><h4 id="取整函数方法"><a href="#取整函数方法" class="headerlink" title="取整函数方法"></a>取整函数方法</h4><h5 id="public-static-double-ceil-double-a-返回大于等于参数的最小整数"><a href="#public-static-double-ceil-double-a-返回大于等于参数的最小整数" class="headerlink" title="public static double ceil(double a)//返回大于等于参数的最小整数"></a><code>public static double ceil(double a)</code>//返回大于等于参数的最小整数</h5><h5 id="public-static-double-floor-double-a-返回小于等于参数的最大整数"><a href="#public-static-double-floor-double-a-返回小于等于参数的最大整数" class="headerlink" title="public static double floor(double a)//返回小于等于参数的最大整数"></a><code>public static double floor(double a)</code>//返回小于等于参数的最大整数</h5><h5 id="public-static-double-rint-double-a-返回与参数最接近的整数-如果两个同为整数且同样接近-则结果取偶数"><a href="#public-static-double-rint-double-a-返回与参数最接近的整数-如果两个同为整数且同样接近-则结果取偶数" class="headerlink" title="public static double rint(double a)//返回与参数最接近的整数,如果两个同为整数且同样接近,则结果取偶数"></a><code>public static double rint(double a)</code>//返回与参数最接近的整数,如果两个同为整数且同样接近,则结果取偶数</h5><h5 id="public-static-int-round-double-a-将参数加上0-5后返回与参数最近的整数"><a href="#public-static-int-round-double-a-将参数加上0-5后返回与参数最近的整数" class="headerlink" title="public static int  round(double a)//将参数加上0.5后返回与参数最近的整数"></a><code>public static int  round(double a)</code>//将参数加上0.5后返回与参数最近的整数</h5><h5 id="public-static-long-round-double-a-将参数加上0-5后返回与参数最近的整数-然后强制转换为长整数"><a href="#public-static-long-round-double-a-将参数加上0-5后返回与参数最近的整数-然后强制转换为长整数" class="headerlink" title="public static  long round(double a)//将参数加上0.5后返回与参数最近的整数,然后强制转换为长整数"></a><code>public static  long round(double a)</code>//将参数加上0.5后返回与参数最近的整数,然后强制转换为长整数</h5><h4 id="取最大值-最小值-绝对值函数方法"><a href="#取最大值-最小值-绝对值函数方法" class="headerlink" title="取最大值,最小值,绝对值函数方法"></a>取最大值,最小值,绝对值函数方法</h4><h5 id="public-static-double-max-double-a-double-b-取a与b之间的最大值"><a href="#public-static-double-max-double-a-double-b-取a与b之间的最大值" class="headerlink" title="public static double max(double a,double b)//取a与b之间的最大值"></a><code>public static double max(double a,double b)</code>//取a与b之间的最大值</h5><h5 id="public-static-int-min-int-a-int-b-取a与b之间的最小值-参数为整型"><a href="#public-static-int-min-int-a-int-b-取a与b之间的最小值-参数为整型" class="headerlink" title="public static int min(int a,int b)//取a与b之间的最小值,参数为整型"></a><code>public static int min(int a,int b)</code>//取a与b之间的最小值,参数为整型</h5><h5 id="public-static-long-min-long-a-long-b-取a与b之间的最小值-参数为长整型"><a href="#public-static-long-min-long-a-long-b-取a与b之间的最小值-参数为长整型" class="headerlink" title="public static long min(long a,long b)//取a与b之间的最小值,参数为长整型"></a><code>public static long min(long a,long b)</code>//取a与b之间的最小值,参数为长整型</h5><h5 id="public-static-float-min-float-a-float-b-取a与b之间的最小值-参数为浮点型"><a href="#public-static-float-min-float-a-float-b-取a与b之间的最小值-参数为浮点型" class="headerlink" title="public static float min(float a,float b)//取a与b之间的最小值,参数为浮点型"></a><code>public static float min(float a,float b)</code>//取a与b之间的最小值,参数为浮点型</h5><h5 id="public-static-double-min-double-a-double-b-取a与b之间的最小值-参数为双精度型"><a href="#public-static-double-min-double-a-double-b-取a与b之间的最小值-参数为双精度型" class="headerlink" title="public static double min(double a,double b)//取a与b之间的最小值,参数为双精度型"></a><code>public static double min(double a,double b)</code>//取a与b之间的最小值,参数为双精度型</h5><h5 id="public-static-int-abs-int-a-返回整型参数的绝对值"><a href="#public-static-int-abs-int-a-返回整型参数的绝对值" class="headerlink" title="public static int abs(int a)//返回整型参数的绝对值"></a><code>public static int abs(int a)</code>//返回整型参数的绝对值</h5><h5 id="public-static-long-abs-long-a-返回长整型参数的绝对值"><a href="#public-static-long-abs-long-a-返回长整型参数的绝对值" class="headerlink" title="public static long abs(long a)//返回长整型参数的绝对值"></a><code>public static long abs(long a)</code>//返回长整型参数的绝对值</h5><h5 id="public-static-float-abs-float-a-返回浮点型参数的绝对值"><a href="#public-static-float-abs-float-a-返回浮点型参数的绝对值" class="headerlink" title="public static float abs( float  a)//返回浮点型参数的绝对值"></a><code>public static float abs( float  a)</code>//返回浮点型参数的绝对值</h5><h5 id="public-static-double-abs-double-a-返回双精度型参数的绝对值"><a href="#public-static-double-abs-double-a-返回双精度型参数的绝对值" class="headerlink" title="public static double abs(double a)//返回双精度型参数的绝对值"></a><code>public static double abs(double a)</code>//返回双精度型参数的绝对值</h5><hr><hr><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="Math-random-方法"><a href="#Math-random-方法" class="headerlink" title="Math.random()方法"></a>Math.random()方法</h3><h4 id="在Math类中存在一个random-方法-用于生产随机数字-这个方法默认生成大于等于0-0且小于1-0的double型随机数-即0-lt-Math-random-lt-1-0-虽然Math-random-方法只可以生产0-1之间的double型数字-其实只要在Math-random-语句上稍加处理-就可以使用这个方法产生任意范围的随机数"><a href="#在Math类中存在一个random-方法-用于生产随机数字-这个方法默认生成大于等于0-0且小于1-0的double型随机数-即0-lt-Math-random-lt-1-0-虽然Math-random-方法只可以生产0-1之间的double型数字-其实只要在Math-random-语句上稍加处理-就可以使用这个方法产生任意范围的随机数" class="headerlink" title="在Math类中存在一个random()方法,用于生产随机数字,这个方法默认生成大于等于0.0且小于1.0的double型随机数,即0&lt;=Math.random()&lt;1.0,虽然Math.random()方法只可以生产0~1之间的double型数字,其实只要在Math.random()语句上稍加处理,就可以使用这个方法产生任意范围的随机数."></a>在Math类中存在一个random()方法,用于生产随机数字,这个方法默认生成大于等于0.0且小于1.0的double型随机数,即0&lt;=Math.random()&lt;1.0,虽然Math.random()方法只可以生产0~1之间的double型数字,其实只要在Math.random()语句上稍加处理,就可以使用这个方法产生任意范围的随机数.</h4><h4 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h4><h5 id="int-s-int-num1-int-Math-random-num2-num1-产生num1-num2之间的随机数"><a href="#int-s-int-num1-int-Math-random-num2-num1-产生num1-num2之间的随机数" class="headerlink" title="int s=(int)num1+(int)(Math.random()*(num2-num1));//产生num1~num2之间的随机数"></a><code>int s=(int)num1+(int)(Math.random()*(num2-num1));</code>//产生num1~num2之间的随机数</h5><h5 id="char-39-a-39-Math-random-39-z-39-39-a-39-1-求出更多的随机字符"><a href="#char-39-a-39-Math-random-39-z-39-39-a-39-1-求出更多的随机字符" class="headerlink" title="(char)(&#39;a&#39;+Math.random()*(&#39;z&#39;-&#39;a&#39;+1));//求出更多的随机字符"></a><code>(char)(&#39;a&#39;+Math.random()*(&#39;z&#39;-&#39;a&#39;+1));</code>//求出更多的随机字符</h5><h5 id="char-char1-Math-random-char2-char1-1-参数设置为随机产生字符的上限与下线"><a href="#char-char1-Math-random-char2-char1-1-参数设置为随机产生字符的上限与下线" class="headerlink" title="(char)(char1+Math.random()*(char2-char1+1));//参数设置为随机产生字符的上限与下线"></a><code>(char)(char1+Math.random()*(char2-char1+1));</code>//参数设置为随机产生字符的上限与下线</h5><h4 id="random-方法返回的值实际上是伪随机数-它通过复杂的运算而得到一系列的数-该方法是通过当前时间作为随机数生成器的参数-所以每次执行程序都会产生不同的随机数"><a href="#random-方法返回的值实际上是伪随机数-它通过复杂的运算而得到一系列的数-该方法是通过当前时间作为随机数生成器的参数-所以每次执行程序都会产生不同的随机数" class="headerlink" title="random()方法返回的值实际上是伪随机数,它通过复杂的运算而得到一系列的数,该方法是通过当前时间作为随机数生成器的参数,所以每次执行程序都会产生不同的随机数"></a>random()方法返回的值实际上是伪随机数,它通过复杂的运算而得到一系列的数,该方法是通过当前时间作为随机数生成器的参数,所以每次执行程序都会产生不同的随机数</h4><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><h4 id="除了Math类中的random-方法可以获取随机数外-Java还提供了一种可以获取随机数的方式-那就是java-util-Random类-可以通过实例化一个Random对象创建一个随机数生成器"><a href="#除了Math类中的random-方法可以获取随机数外-Java还提供了一种可以获取随机数的方式-那就是java-util-Random类-可以通过实例化一个Random对象创建一个随机数生成器" class="headerlink" title="除了Math类中的random()方法可以获取随机数外,Java还提供了一种可以获取随机数的方式,那就是java.util.Random类,可以通过实例化一个Random对象创建一个随机数生成器"></a>除了Math类中的random()方法可以获取随机数外,Java还提供了一种可以获取随机数的方式,那就是java.util.Random类,可以通过实例化一个Random对象创建一个随机数生成器</h4><h5 id="RAndom-r-new-Random"><a href="#RAndom-r-new-Random" class="headerlink" title="RAndom r = new Random();"></a><code>RAndom r = new Random();</code></h5><h5 id="java编译器以系统当前时间作为随机数生成器的种子-因为每时每刻的时间不可能相同-所以产生的随机数将不同-但是如果运行速度太快-也会产生两次运行结果相同的随机数"><a href="#java编译器以系统当前时间作为随机数生成器的种子-因为每时每刻的时间不可能相同-所以产生的随机数将不同-但是如果运行速度太快-也会产生两次运行结果相同的随机数" class="headerlink" title="java编译器以系统当前时间作为随机数生成器的种子,因为每时每刻的时间不可能相同,所以产生的随机数将不同,但是如果运行速度太快,也会产生两次运行结果相同的随机数,"></a>java编译器以系统当前时间作为随机数生成器的种子,因为每时每刻的时间不可能相同,所以产生的随机数将不同,但是如果运行速度太快,也会产生两次运行结果相同的随机数,</h5><h5 id="同时也可以在括号了加入seedValue作为随机数生成器的种子"><a href="#同时也可以在括号了加入seedValue作为随机数生成器的种子" class="headerlink" title="同时也可以在括号了加入seedValue作为随机数生成器的种子"></a>同时也可以在括号了加入seedValue作为随机数生成器的种子</h5><h5 id="在RAndom类中提供了获取各种数据类型随机数的方法"><a href="#在RAndom类中提供了获取各种数据类型随机数的方法" class="headerlink" title="在RAndom类中提供了获取各种数据类型随机数的方法,"></a>在RAndom类中提供了获取各种数据类型随机数的方法,</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//随机产生一个整数</span></span><br><span class="line">System.out.println(r.nextInt());</span><br><span class="line"><span class="comment">//随机产生一个大于等于0且小于10的整数</span></span><br><span class="line">System.out.println(r.nextInt(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//随机产生一个布尔型的值</span></span><br><span class="line">System.out.println(r.nextBoolean());</span><br><span class="line"><span class="comment">//随机产生一个双精度型的值</span></span><br><span class="line">System.out.println(r.nextDouble());</span><br><span class="line"><span class="comment">//随机产生一个浮点型的值</span></span><br><span class="line">System.out.println(r.nextFloat());</span><br><span class="line"><span class="comment">//随机产生一个概率密度为高斯分布的双精度值</span></span><br><span class="line">System.out.println(r.nextGaussian());</span><br></pre></td></tr></table></figure><h4 id="高斯分布-正态分布"><a href="#高斯分布-正态分布" class="headerlink" title="高斯分布:正态分布"></a>高斯分布:正态分布</h4><hr><hr><h2 id="大数字运算"><a href="#大数字运算" class="headerlink" title="大数字运算"></a>大数字运算</h2><h3 id="定义-Java中提供了大数字的操作类-即java-math-BigInteger类与java-math-BigDecimal类-这两个类用于高精度运算-其中BigInteger类是针对大整数的处理类-而BigDecimal类则是针对大小数的处理类"><a href="#定义-Java中提供了大数字的操作类-即java-math-BigInteger类与java-math-BigDecimal类-这两个类用于高精度运算-其中BigInteger类是针对大整数的处理类-而BigDecimal类则是针对大小数的处理类" class="headerlink" title="定义:Java中提供了大数字的操作类.即java.math.BigInteger类与java.math.BigDecimal类,这两个类用于高精度运算,其中BigInteger类是针对大整数的处理类,而BigDecimal类则是针对大小数的处理类."></a>定义:Java中提供了大数字的操作类.即java.math.BigInteger类与java.math.BigDecimal类,这两个类用于高精度运算,其中BigInteger类是针对大整数的处理类,而BigDecimal类则是针对大小数的处理类.</h3><h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><h5 id="int最大的数为2的31次方-1-如果要计算更大的数字-则用BigInteger-支持任意精度的整数-也就是说在运算中BigInteger类型可以准确地表示任何大小的整数值而不会丢失任何信息"><a href="#int最大的数为2的31次方-1-如果要计算更大的数字-则用BigInteger-支持任意精度的整数-也就是说在运算中BigInteger类型可以准确地表示任何大小的整数值而不会丢失任何信息" class="headerlink" title="int最大的数为2的31次方-1,如果要计算更大的数字,则用BigInteger,支持任意精度的整数,也就是说在运算中BigInteger类型可以准确地表示任何大小的整数值而不会丢失任何信息"></a>int最大的数为2的31次方-1,如果要计算更大的数字,则用BigInteger,支持任意精度的整数,也就是说在运算中BigInteger类型可以准确地表示任何大小的整数值而不会丢失任何信息</h5><h5 id="使用BigInteger类-可以实例化一个BigInteger对象-并自动调用相应的构造函数"><a href="#使用BigInteger类-可以实例化一个BigInteger对象-并自动调用相应的构造函数" class="headerlink" title="使用BigInteger类,可以实例化一个BigInteger对象,并自动调用相应的构造函数."></a>使用BigInteger类,可以实例化一个BigInteger对象,并自动调用相应的构造函数.</h5><h5 id="BigInteger类具有很多构造函数-但最直接的一种方式是参数以字符串形式代表要处理的数字"><a href="#BigInteger类具有很多构造函数-但最直接的一种方式是参数以字符串形式代表要处理的数字" class="headerlink" title="BigInteger类具有很多构造函数,但最直接的一种方式是参数以字符串形式代表要处理的数字"></a>BigInteger类具有很多构造函数,但最直接的一种方式是参数以字符串形式代表要处理的数字</h5><h6 id="public-BigInteger-String-val"><a href="#public-BigInteger-String-val" class="headerlink" title="public BigInteger(String val)"></a><code>public BigInteger(String val)</code></h6><h6 id="BigInteger-twoInstance-new-BigInteger-quot-2-quot-将十进制2转换为BigInteger形式"><a href="#BigInteger-twoInstance-new-BigInteger-quot-2-quot-将十进制2转换为BigInteger形式" class="headerlink" title="BigInteger twoInstance = new BigInteger(&quot;2&quot;);//将十进制2转换为BigInteger形式"></a><code>BigInteger twoInstance = new BigInteger(&quot;2&quot;);</code>//将十进制2转换为BigInteger形式</h6><h6 id="参数2的双引号不能省略-因为参数是以字符串的形式存在的"><a href="#参数2的双引号不能省略-因为参数是以字符串的形式存在的" class="headerlink" title="参数2的双引号不能省略,因为参数是以字符串的形式存在的"></a>参数2的双引号不能省略,因为参数是以字符串的形式存在的</h6><h6 id="下面列举了BigInteger类中常用的几种运算方法"><a href="#下面列举了BigInteger类中常用的几种运算方法" class="headerlink" title="下面列举了BigInteger类中常用的几种运算方法"></a>下面列举了BigInteger类中常用的几种运算方法</h6><h6 id="public-BigInteger-add-BigInteger-val-做加法运算"><a href="#public-BigInteger-add-BigInteger-val-做加法运算" class="headerlink" title="public BigInteger add(BigInteger val)//做加法运算"></a><code>public BigInteger add(BigInteger val)</code>//做加法运算</h6><h6 id="public-BigInteger-subtract-BigInteger-val-做减法运算"><a href="#public-BigInteger-subtract-BigInteger-val-做减法运算" class="headerlink" title="public BigInteger subtract(BigInteger val)//做减法运算"></a><code>public BigInteger subtract(BigInteger val)</code>//做减法运算</h6><h6 id="public-BigInteger-multiply-BigInteger-val-做乘法运算"><a href="#public-BigInteger-multiply-BigInteger-val-做乘法运算" class="headerlink" title="public BigInteger multiply(BigInteger val)//做乘法运算"></a><code>public BigInteger multiply(BigInteger val)</code>//做乘法运算</h6><h6 id="public-BigInteger-divide-BigInteger-val-做除法运算"><a href="#public-BigInteger-divide-BigInteger-val-做除法运算" class="headerlink" title="public BigInteger divide(BigInteger val)//做除法运算"></a><code>public BigInteger divide(BigInteger val)</code>//做除法运算</h6><h6 id="public-BigInteger-remainder-BigInteger-val-做取余操作"><a href="#public-BigInteger-remainder-BigInteger-val-做取余操作" class="headerlink" title="public BigInteger remainder(BigInteger val)//做取余操作"></a><code>public BigInteger remainder(BigInteger val)</code>//做取余操作</h6><h6 id="public-BigInteger-divideAndRemainder-BigInteger-val-用数组返回余数和商-结果数组中第一个值为商-第二个值为余数"><a href="#public-BigInteger-divideAndRemainder-BigInteger-val-用数组返回余数和商-结果数组中第一个值为商-第二个值为余数" class="headerlink" title="public BigInteger[] divideAndRemainder(BigInteger val)//用数组返回余数和商,结果数组中第一个值为商,第二个值为余数"></a><code>public BigInteger[] divideAndRemainder(BigInteger val)</code>//用数组返回余数和商,结果数组中第一个值为商,第二个值为余数</h6><h6 id="public-BigInteger-pow-int-exponent-进行取参数的exponent次方操作"><a href="#public-BigInteger-pow-int-exponent-进行取参数的exponent次方操作" class="headerlink" title="public BigInteger pow(int exponent)//进行取参数的exponent次方操作"></a><code>public BigInteger pow(int exponent)</code>//进行取参数的exponent次方操作</h6><h6 id="public-BigInteger-negate-取相反数"><a href="#public-BigInteger-negate-取相反数" class="headerlink" title="public BigInteger negate()//取相反数"></a><code>public BigInteger negate()</code>//取相反数</h6><h6 id="public-BigInteger-shiftLeft-int-n-将数字左移n位-如果n为负数-做右移操作"><a href="#public-BigInteger-shiftLeft-int-n-将数字左移n位-如果n为负数-做右移操作" class="headerlink" title="public BigInteger shiftLeft(int n)//将数字左移n位,如果n为负数,做右移操作"></a><code>public BigInteger shiftLeft(int n)</code>//将数字左移n位,如果n为负数,做右移操作</h6><h6 id="public-BigInteger-shiftRight-int-n-将数字右移n位-如果n为负数-做左移操作"><a href="#public-BigInteger-shiftRight-int-n-将数字右移n位-如果n为负数-做左移操作" class="headerlink" title="public BigInteger shiftRight(int n)//将数字右移n位,如果n为负数,做左移操作"></a><code>public BigInteger shiftRight(int n)</code>//将数字右移n位,如果n为负数,做左移操作</h6><h6 id="public-BigInteger-and-BigInteger-val-做与操作"><a href="#public-BigInteger-and-BigInteger-val-做与操作" class="headerlink" title="public BigInteger and(BigInteger val)//做与操作"></a><code>public BigInteger and(BigInteger val)</code>//做与操作</h6><h6 id="public-BigInteger-or-BigInteger-val-做或操作"><a href="#public-BigInteger-or-BigInteger-val-做或操作" class="headerlink" title="public BigInteger or(BigInteger val)//做或操作"></a><code>public BigInteger or(BigInteger val)</code>//做或操作</h6><h6 id="public-int-compareTo-BigInteger-val-做数字比较操作"><a href="#public-int-compareTo-BigInteger-val-做数字比较操作" class="headerlink" title="public int compareTo(BigInteger val)//做数字比较操作"></a><code>public int compareTo(BigInteger val)</code>//做数字比较操作</h6><h6 id="public-BigInteger-min-BigInteger-val-返回较小的数值"><a href="#public-BigInteger-min-BigInteger-val-返回较小的数值" class="headerlink" title="public BigInteger min(BigInteger val)//返回较小的数值"></a><code>public BigInteger min(BigInteger val)</code>//返回较小的数值</h6><h6 id="public-BigInteger-max-BigInteger-val-返回较大的数值"><a href="#public-BigInteger-max-BigInteger-val-返回较大的数值" class="headerlink" title="public BigInteger max(BigInteger val)//返回较大的数值"></a><code>public BigInteger max(BigInteger val)</code>//返回较大的数值</h6><h6 id="public-Boolean-equals-Object-x-当参数x是BigInteger类型的数字并且数值相等时-返回true"><a href="#public-Boolean-equals-Object-x-当参数x是BigInteger类型的数字并且数值相等时-返回true" class="headerlink" title="public Boolean equals(Object x)//当参数x是BigInteger类型的数字并且数值相等时,返回true"></a><code>public Boolean equals(Object x)</code>//当参数x是BigInteger类型的数字并且数值相等时,返回true</h6><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><h5 id="定义-两个都能实现大数字运算-不同的是BigDecimal加入了小数的概念-一般的float型和double型数据只可以用来做科学计算或工程设计-但由于在商业计算中要求数字精度比较高-所以要用到java-math-BigDecimal类"><a href="#定义-两个都能实现大数字运算-不同的是BigDecimal加入了小数的概念-一般的float型和double型数据只可以用来做科学计算或工程设计-但由于在商业计算中要求数字精度比较高-所以要用到java-math-BigDecimal类" class="headerlink" title="定义:两个都能实现大数字运算,不同的是BigDecimal加入了小数的概念.一般的float型和double型数据只可以用来做科学计算或工程设计,但由于在商业计算中要求数字精度比较高,所以要用到java.math.BigDecimal类."></a>定义:两个都能实现大数字运算,不同的是BigDecimal加入了小数的概念.一般的float型和double型数据只可以用来做科学计算或工程设计,但由于在商业计算中要求数字精度比较高,所以要用到java.math.BigDecimal类.</h5><h5 id="BigDecimal类支持任何精度的定点数-可以用它来精确计算货币值"><a href="#BigDecimal类支持任何精度的定点数-可以用它来精确计算货币值" class="headerlink" title="BigDecimal类支持任何精度的定点数,可以用它来精确计算货币值"></a>BigDecimal类支持任何精度的定点数,可以用它来精确计算货币值</h5><h5 id="在BigDecimal类中常用的两个构造方法"><a href="#在BigDecimal类中常用的两个构造方法" class="headerlink" title="在BigDecimal类中常用的两个构造方法"></a>在BigDecimal类中常用的两个构造方法</h5><h6 id="public-BigDecimal-double-val-实例化时将双精度型转换为BigDecimal类型"><a href="#public-BigDecimal-double-val-实例化时将双精度型转换为BigDecimal类型" class="headerlink" title="public BigDecimal(double val)://实例化时将双精度型转换为BigDecimal类型"></a><code>public BigDecimal(double val):</code>//实例化时将双精度型转换为BigDecimal类型</h6><h6 id="public-BigDecimal-String-val-实例化时将字符串形式转换为BigDecimal类型"><a href="#public-BigDecimal-String-val-实例化时将字符串形式转换为BigDecimal类型" class="headerlink" title="public BigDecimal(String val)://实例化时将字符串形式转换为BigDecimal类型"></a><code>public BigDecimal(String val):</code>//实例化时将字符串形式转换为BigDecimal类型</h6><h5 id="下面列举了BigDecimal类中实现加-减-乘-除的方法"><a href="#下面列举了BigDecimal类中实现加-减-乘-除的方法" class="headerlink" title="下面列举了BigDecimal类中实现加,减,乘,除的方法"></a>下面列举了BigDecimal类中实现加,减,乘,除的方法</h5><h6 id="public-BigDecimal-add-BigDecimal-augend-做加法操作"><a href="#public-BigDecimal-add-BigDecimal-augend-做加法操作" class="headerlink" title="public BigDecimal add(BigDecimal augend);//做加法操作"></a><code>public BigDecimal add(BigDecimal augend);</code>//做加法操作</h6><h6 id="public-BigDecimal-subtract-BigDecimal-subtrahend-做减法操作"><a href="#public-BigDecimal-subtract-BigDecimal-subtrahend-做减法操作" class="headerlink" title="public BigDecimal subtract(BigDecimal subtrahend);//做减法操作"></a><code>public BigDecimal subtract(BigDecimal subtrahend);</code>//做减法操作</h6><h6 id="public-BigDecimal-multiply-BigDecimal-multiplicand-做乘法操作"><a href="#public-BigDecimal-multiply-BigDecimal-multiplicand-做乘法操作" class="headerlink" title="public BigDecimal multiply(BigDecimal multiplicand);//做乘法操作"></a><code>public BigDecimal multiply(BigDecimal multiplicand);</code>//做乘法操作</h6><h6 id="public-BigDecimal-divide-BigDecimal-divisor-int-scale-int-roundingMode-做除法操作-方法中3个参数分别代表除数-商的小数点后的维数-近似处理模式"><a href="#public-BigDecimal-divide-BigDecimal-divisor-int-scale-int-roundingMode-做除法操作-方法中3个参数分别代表除数-商的小数点后的维数-近似处理模式" class="headerlink" title="public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode)//做除法操作,方法中3个参数分别代表除数,商的小数点后的维数,近似处理模式"></a><code>public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode)</code>//做除法操作,方法中3个参数分别代表除数,商的小数点后的维数,近似处理模式</h6><h6 id="divide-方法有多种设置-用于返回商末位小数点的处理"><a href="#divide-方法有多种设置-用于返回商末位小数点的处理" class="headerlink" title="divide()方法有多种设置,用于返回商末位小数点的处理:"></a>divide()方法有多种设置,用于返回商末位小数点的处理:</h6><h6 id="BigDecimal-ROUND-UP-商的最后一位如果大于0-则向前进位-正负数都如此"><a href="#BigDecimal-ROUND-UP-商的最后一位如果大于0-则向前进位-正负数都如此" class="headerlink" title="BigDecimal.ROUND_UP:商的最后一位如果大于0,则向前进位,正负数都如此"></a>BigDecimal.ROUND_UP:商的最后一位如果大于0,则向前进位,正负数都如此</h6><h6 id="BigDecimal-ROUND-DOWN-商的最后一位无论是什么数字都省略"><a href="#BigDecimal-ROUND-DOWN-商的最后一位无论是什么数字都省略" class="headerlink" title="BigDecimal.ROUND_DOWN:商的最后一位无论是什么数字都省略"></a>BigDecimal.ROUND_DOWN:商的最后一位无论是什么数字都省略</h6><h6 id="BigDecimal-ROUND-CEILING-商如果是整数-按照ROUND-UP模式处理-如果是负数-按照ROUND-DOWN模式处理．这种模式的处理都会使近似值大于等于实际值"><a href="#BigDecimal-ROUND-CEILING-商如果是整数-按照ROUND-UP模式处理-如果是负数-按照ROUND-DOWN模式处理．这种模式的处理都会使近似值大于等于实际值" class="headerlink" title="BigDecimal.ROUND_CEILING:商如果是整数,按照ROUND_UP模式处理;如果是负数,按照ROUND_DOWN模式处理．这种模式的处理都会使近似值大于等于实际值"></a>BigDecimal.ROUND_CEILING:商如果是整数,按照ROUND_UP模式处理;如果是负数,按照ROUND_DOWN模式处理．这种模式的处理都会使近似值大于等于实际值</h6><h6 id="BigDecimal-ROUND-FLOOR-与ROUND-CEILING模式相反，商如果是整数，按照ROUND＿DOWN模式处理-商如果是负数-则按照ROUND-UP模式处理-这种模式的处理都会使近似值小于等于实际值"><a href="#BigDecimal-ROUND-FLOOR-与ROUND-CEILING模式相反，商如果是整数，按照ROUND＿DOWN模式处理-商如果是负数-则按照ROUND-UP模式处理-这种模式的处理都会使近似值小于等于实际值" class="headerlink" title="BigDecimal.ROUND_FLOOR:与ROUND_CEILING模式相反，商如果是整数，按照ＲＯＵＮＤ＿ＤＯＷＮ模式处理;商如果是负数,则按照ROUND_UP模式处理,这种模式的处理都会使近似值小于等于实际值"></a>BigDecimal.ROUND_FLOOR:与ROUND_CEILING模式相反，商如果是整数，按照ＲＯＵＮＤ＿ＤＯＷＮ模式处理;商如果是负数,则按照ROUND_UP模式处理,这种模式的处理都会使近似值小于等于实际值</h6><h6 id="BigDecimal-ROUND-HALF-DOWN-对商进行四舍五入操作-如果商最后一位小于等于5-则做舍弃操作-如果最后一位大于5-则做出进位操作"><a href="#BigDecimal-ROUND-HALF-DOWN-对商进行四舍五入操作-如果商最后一位小于等于5-则做舍弃操作-如果最后一位大于5-则做出进位操作" class="headerlink" title="BigDecimal.ROUND_HALF_DOWN:对商进行四舍五入操作,如果商最后一位小于等于5,则做舍弃操作;如果最后一位大于5,则做出进位操作"></a>BigDecimal.ROUND_HALF_DOWN:对商进行四舍五入操作,如果商最后一位小于等于5,则做舍弃操作;如果最后一位大于5,则做出进位操作</h6><h6 id="BigDecimal-ROUND-HALF-UP-对商进行四舍五入操作-如果商的最后一位小于5则舍弃-如果大于等于5-进行进位操作"><a href="#BigDecimal-ROUND-HALF-UP-对商进行四舍五入操作-如果商的最后一位小于5则舍弃-如果大于等于5-进行进位操作" class="headerlink" title="BigDecimal.ROUND_HALF_UP:对商进行四舍五入操作,如果商的最后一位小于5则舍弃;如果大于等于5,进行进位操作"></a>BigDecimal.ROUND_HALF_UP:对商进行四舍五入操作,如果商的最后一位小于5则舍弃;如果大于等于5,进行进位操作</h6><h6 id="BigDecimal-ROUND-HALF-EVEN-如果商的倒数第二位为奇数-则按照ROUND-HALF-UP处理-如果为偶数-则按照ROUND-HALF-DOWN处理"><a href="#BigDecimal-ROUND-HALF-EVEN-如果商的倒数第二位为奇数-则按照ROUND-HALF-UP处理-如果为偶数-则按照ROUND-HALF-DOWN处理" class="headerlink" title="BigDecimal.ROUND_HALF_EVEN:如果商的倒数第二位为奇数,则按照ROUND_HALF_UP处理;如果为偶数,则按照ROUND_HALF_DOWN处理,"></a>BigDecimal.ROUND_HALF_EVEN:如果商的倒数第二位为奇数,则按照ROUND_HALF_UP处理;如果为偶数,则按照ROUND_HALF_DOWN处理,</h6>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/15/java%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E7%B1%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java包装类</title>
      <link>http://example.com/2021/06/14/java%E5%8C%85%E8%A3%85%E7%B1%BB/</link>
      <guid>http://example.com/2021/06/14/java%E5%8C%85%E8%A3%85%E7%B1%BB/</guid>
      <pubDate>Mon, 14 Jun 2021 05:03:09 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;包装类&quot;&gt;&lt;a href=&quot;#包装类&quot; class=&quot;headerlink&quot; title=&quot;包装类&quot;&gt;&lt;/a&gt;包装类&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><span id="more"></span><h2 id="意义-Java是一种面向对象语言-Java中的类把方法与数据连接在一起-构成了自包含式的处理单元-但在Java中不能定义基本类型对象-为了能将基本类型视为对象进行处理-并能连接相关的方法-Java为每个基本类型都提供了包装类-这样便可以把这些基本类型转换为对象来处理了"><a href="#意义-Java是一种面向对象语言-Java中的类把方法与数据连接在一起-构成了自包含式的处理单元-但在Java中不能定义基本类型对象-为了能将基本类型视为对象进行处理-并能连接相关的方法-Java为每个基本类型都提供了包装类-这样便可以把这些基本类型转换为对象来处理了" class="headerlink" title="意义:Java是一种面向对象语言,Java中的类把方法与数据连接在一起,构成了自包含式的处理单元..但在Java中不能定义基本类型对象,为了能将基本类型视为对象进行处理,并能连接相关的方法,Java为每个基本类型都提供了包装类,这样便可以把这些基本类型转换为对象来处理了"></a>意义:Java是一种面向对象语言,Java中的类把方法与数据连接在一起,构成了自包含式的处理单元..但在Java中不能定义基本类型对象,为了能将基本类型视为对象进行处理,并能连接相关的方法,Java为每个基本类型都提供了包装类,这样便可以把这些基本类型转换为对象来处理了</h2><h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="java-lang包中的Integer类-Long类和short类-分别将基本类型-其包含的方法基本相同"><a href="#java-lang包中的Integer类-Long类和short类-分别将基本类型-其包含的方法基本相同" class="headerlink" title="java.lang包中的Integer类,Long类和short类,分别将基本类型,其包含的方法基本相同."></a>java.lang包中的Integer类,Long类和short类,分别将基本类型,其包含的方法基本相同.</h4><h4 id="Integer类在对象中包装了一个基本类型int的值-该类的对象包含了一个int类型的字段-此外-该类提供了多个方法-能在int类型和String类型之间相互转换-同时还提供了其他一些处理int类型时非常有用的常量和方法"><a href="#Integer类在对象中包装了一个基本类型int的值-该类的对象包含了一个int类型的字段-此外-该类提供了多个方法-能在int类型和String类型之间相互转换-同时还提供了其他一些处理int类型时非常有用的常量和方法" class="headerlink" title="Integer类在对象中包装了一个基本类型int的值.该类的对象包含了一个int类型的字段,此外,该类提供了多个方法,能在int类型和String类型之间相互转换,同时还提供了其他一些处理int类型时非常有用的常量和方法"></a>Integer类在对象中包装了一个基本类型int的值.该类的对象包含了一个int类型的字段,此外,该类提供了多个方法,能在int类型和String类型之间相互转换,同时还提供了其他一些处理int类型时非常有用的常量和方法</h4><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="Integer-int-number"><a href="#Integer-int-number" class="headerlink" title="Integer(int number)"></a><code>Integer(int number)</code></h4><h5 id="该方法以一个int型变量作为参数来获取Integer对象"><a href="#该方法以一个int型变量作为参数来获取Integer对象" class="headerlink" title="该方法以一个int型变量作为参数来获取Integer对象"></a>该方法以一个int型变量作为参数来获取Integer对象</h5><h4 id="Integer-String-str"><a href="#Integer-String-str" class="headerlink" title="Integer(String str)"></a>Integer(String str)</h4><h5 id="该方法以一个String型变量作为参数来获取Integer对象"><a href="#该方法以一个String型变量作为参数来获取Integer对象" class="headerlink" title="该方法以一个String型变量作为参数来获取Integer对象"></a>该方法以一个String型变量作为参数来获取Integer对象</h5><h5 id="要用数值型String变量作为参数，如123，否则将会抛出NumberFormatException异常"><a href="#要用数值型String变量作为参数，如123，否则将会抛出NumberFormatException异常" class="headerlink" title="要用数值型String变量作为参数，如123，否则将会抛出NumberFormatException异常"></a>要用数值型String变量作为参数，如123，否则将会抛出NumberFormatException异常</h5><h4 id="Integer类的常用方法"><a href="#Integer类的常用方法" class="headerlink" title="Integer类的常用方法"></a>Integer类的常用方法</h4><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="返回值-功能描述"><a href="#返回值-功能描述" class="headerlink" title="返回值:功能描述"></a>返回值:功能描述</h6><h5 id="byteValue"><a href="#byteValue" class="headerlink" title="byteValue()"></a><code>byteValue()</code></h5><h6 id="byte-以byte类型返回该integer的值"><a href="#byte-以byte类型返回该integer的值" class="headerlink" title="byte:以byte类型返回该integer的值"></a>byte:以byte类型返回该integer的值</h6><h5 id="compareTo-Integer-anotherInteger"><a href="#compareTo-Integer-anotherInteger" class="headerlink" title="compareTo(Integer anotherInteger)"></a><code>compareTo(Integer anotherInteger)</code></h5><h6 id="int-在数字上比较两个Integer对象。如果这两个值相等，则返回-0；如果调用对象的数值小于anotherInteger的数值，则返回负值；-如果调用对象的数值大于anotherInteger的数值，则返回正值"><a href="#int-在数字上比较两个Integer对象。如果这两个值相等，则返回-0；如果调用对象的数值小于anotherInteger的数值，则返回负值；-如果调用对象的数值大于anotherInteger的数值，则返回正值" class="headerlink" title="int:在数字上比较两个Integer对象。如果这两个值相等，则返回 *                                                  0；如果调用对象的数值小于anotherInteger的数值，则返回负值； *                                                  如果调用对象的数值大于anotherInteger的数值，则返回正值"></a>int:在数字上比较两个Integer对象。如果这两个值相等，则返回 *                                                  0；如果调用对象的数值小于anotherInteger的数值，则返回负值； *                                                  如果调用对象的数值大于anotherInteger的数值，则返回正值</h6><h5 id="equals-Object-IntegerObj"><a href="#equals-Object-IntegerObj" class="headerlink" title="equals(Object IntegerObj)"></a><code>equals(Object IntegerObj)</code></h5><h6 id="boolean-比较此对象与指定的对象是否平等"><a href="#boolean-比较此对象与指定的对象是否平等" class="headerlink" title="boolean:比较此对象与指定的对象是否平等"></a>boolean:比较此对象与指定的对象是否平等</h6><h5 id="intValue"><a href="#intValue" class="headerlink" title="intValue()"></a><code>intValue()</code></h5><h6 id="int-以int型返回此Integer对象"><a href="#int-以int型返回此Integer对象" class="headerlink" title="int:以int型返回此Integer对象"></a>int:以int型返回此Integer对象</h6><h5 id="shortValue"><a href="#shortValue" class="headerlink" title="shortValue()"></a>shortValue()</h5><h6 id="short-以short型返回此Integer对象"><a href="#short-以short型返回此Integer对象" class="headerlink" title="short: 以short型返回此Integer对象"></a>short: 以short型返回此Integer对象</h6><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><h6 id="String-返回一个表示该Integer值的String对象-转换为十进制字符串表示"><a href="#String-返回一个表示该Integer值的String对象-转换为十进制字符串表示" class="headerlink" title="String:返回一个表示该Integer值的String对象(转换为十进制字符串表示)"></a>String:返回一个表示该Integer值的String对象(转换为十进制字符串表示)</h6><h5 id="valueOf-String-str"><a href="#valueOf-String-str" class="headerlink" title="valueOf(String str)"></a>valueOf(String str)</h5><h6 id="Integer-返回保存指定的String值的Integer对象"><a href="#Integer-返回保存指定的String值的Integer对象" class="headerlink" title="Integer:返回保存指定的String值的Integer对象"></a>Integer:返回保存指定的String值的Integer对象</h6><h5 id="parseInt-String-str"><a href="#parseInt-String-str" class="headerlink" title="parseInt(String str)"></a>parseInt(String str)</h5><h6 id="int-返回包含在由str指定的字符串中的数字的等价整数值"><a href="#int-返回包含在由str指定的字符串中的数字的等价整数值" class="headerlink" title="int:返回包含在由str指定的字符串中的数字的等价整数值"></a>int:返回包含在由str指定的字符串中的数字的等价整数值</h6><h5 id="toBinaryString-toHexString-toOctalString"><a href="#toBinaryString-toHexString-toOctalString" class="headerlink" title="toBinaryString(),toHexString(),toOctalString()"></a><code>toBinaryString(),toHexString(),toOctalString()</code></h5><h6 id="分别将值转换成二进制，十六进制，八进制"><a href="#分别将值转换成二进制，十六进制，八进制" class="headerlink" title="分别将值转换成二进制，十六进制，八进制"></a>分别将值转换成二进制，十六进制，八进制</h6><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><h5 id="MAX-VALUE-表示int类习惯可取的最大值"><a href="#MAX-VALUE-表示int类习惯可取的最大值" class="headerlink" title="MAX_VALUE:表示int类习惯可取的最大值"></a>MAX_VALUE:表示int类习惯可取的最大值</h5><h5 id="MIN-VALUE-表示int类型可取的最小值"><a href="#MIN-VALUE-表示int类型可取的最小值" class="headerlink" title="MIN_VALUE:表示int类型可取的最小值"></a>MIN_VALUE:表示int类型可取的最小值</h5><h5 id="SIZE-用以二进制补码形式表示int值的位数"><a href="#SIZE-用以二进制补码形式表示int值的位数" class="headerlink" title="SIZE:用以二进制补码形式表示int值的位数"></a>SIZE:用以二进制补码形式表示int值的位数</h5><h5 id="TYPE-表示基本类型int的Class实例"><a href="#TYPE-表示基本类型int的Class实例" class="headerlink" title="TYPE:表示基本类型int的Class实例"></a>TYPE:表示基本类型int的Class实例</h5><hr><hr><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><h3 id="定义-Boolean类将基本类型为boolean的值包装在一个对象中-一个Boolean类型的对象值包含一个类型为boolean的字段-此外-此类还为boolean和String的相互转换提供了许多方法-并提供了处理boolean时非常有用的其他一些方法和常量"><a href="#定义-Boolean类将基本类型为boolean的值包装在一个对象中-一个Boolean类型的对象值包含一个类型为boolean的字段-此外-此类还为boolean和String的相互转换提供了许多方法-并提供了处理boolean时非常有用的其他一些方法和常量" class="headerlink" title="定义:Boolean类将基本类型为boolean的值包装在一个对象中,一个Boolean类型的对象值包含一个类型为boolean的字段,此外,此类还为boolean和String的相互转换提供了许多方法,并提供了处理boolean时非常有用的其他一些方法和常量"></a>定义:Boolean类将基本类型为boolean的值包装在一个对象中,一个Boolean类型的对象值包含一个类型为boolean的字段,此外,此类还为boolean和String的相互转换提供了许多方法,并提供了处理boolean时非常有用的其他一些方法和常量</h3><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="Boolean-boolean-value-该方法创建一个表示value参数的Boolean对象"><a href="#Boolean-boolean-value-该方法创建一个表示value参数的Boolean对象" class="headerlink" title="Boolean(boolean value)//该方法创建一个表示value参数的Boolean对象"></a><code>Boolean(boolean value)</code>//该方法创建一个表示value参数的Boolean对象</h4><h4 id="Boolean-String-str-该方法以String变量作为参数创建Boolean对象。如果String参数不为null且在忽略-大小写时等于true，则分配一个表示true值的Boolean对象，否则获得一个false值的Boolean对象"><a href="#Boolean-String-str-该方法以String变量作为参数创建Boolean对象。如果String参数不为null且在忽略-大小写时等于true，则分配一个表示true值的Boolean对象，否则获得一个false值的Boolean对象" class="headerlink" title="Boolean(String str)//该方法以String变量作为参数创建Boolean对象。如果String参数不为null且在忽略 大小写时等于true，则分配一个表示true值的Boolean对象，否则获得一个false值的Boolean对象"></a><code>Boolean(String str)</code>//该方法以String变量作为参数创建Boolean对象。如果String参数不为null且在忽略 大小写时等于true，则分配一个表示true值的Boolean对象，否则获得一个false值的Boolean对象</h4><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="booleanValue"><a href="#booleanValue" class="headerlink" title="booleanValue()"></a>booleanValue()</h4><h5 id="boolean-将Boolean对象的值以对应的Boolean值返回"><a href="#boolean-将Boolean对象的值以对应的Boolean值返回" class="headerlink" title="boolean:将Boolean对象的值以对应的Boolean值返回"></a>boolean:将Boolean对象的值以对应的Boolean值返回</h5><h4 id="equals-Object-obj"><a href="#equals-Object-obj" class="headerlink" title="equals(Object obj)"></a>equals(Object obj)</h4><h5 id="boolean-判断调用该方法的对象与obj是否相等。当且仅当参数不是null，而且与调用-该方法的对象一样都表示同一个Boolean值的Boolean对象时，才返回true"><a href="#boolean-判断调用该方法的对象与obj是否相等。当且仅当参数不是null，而且与调用-该方法的对象一样都表示同一个Boolean值的Boolean对象时，才返回true" class="headerlink" title="boolean:判断调用该方法的对象与obj是否相等。当且仅当参数不是null，而且与调用                                  该方法的对象一样都表示同一个Boolean值的Boolean对象时，才返回true"></a>boolean:判断调用该方法的对象与obj是否相等。当且仅当参数不是null，而且与调用                                  该方法的对象一样都表示同一个Boolean值的Boolean对象时，才返回true</h5><h4 id="parseBoolean-String-s"><a href="#parseBoolean-String-s" class="headerlink" title="parseBoolean(String s)"></a><code>parseBoolean(String s)</code></h4><h5 id="boolean-将字符串参数解析为Boolean"><a href="#boolean-将字符串参数解析为Boolean" class="headerlink" title="boolean:将字符串参数解析为Boolean"></a>boolean:将字符串参数解析为Boolean</h5><h4 id="toString"><a href="#toString" class="headerlink" title="toString()"></a><code>toString()</code></h4><h5 id="String-返回表示该Boolean值的String对象"><a href="#String-返回表示该Boolean值的String对象" class="headerlink" title="String:返回表示该Boolean值的String对象"></a>String:返回表示该Boolean值的String对象</h5><h4 id="valueDf-String-s"><a href="#valueDf-String-s" class="headerlink" title="valueDf(String s)"></a><code>valueDf(String s)</code></h4><h5 id="boolean-返回一个用指定的字符串表示值的Boolean值"><a href="#boolean-返回一个用指定的字符串表示值的Boolean值" class="headerlink" title="boolean:返回一个用指定的字符串表示值的Boolean值"></a>boolean:返回一个用指定的字符串表示值的Boolean值</h5><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><h4 id="TRUE-对应基值true的Boolean对象"><a href="#TRUE-对应基值true的Boolean对象" class="headerlink" title="TRUE:对应基值true的Boolean对象"></a>TRUE:对应基值true的Boolean对象</h4><h4 id="FALSE-对应基值false的Boolean对象"><a href="#FALSE-对应基值false的Boolean对象" class="headerlink" title="FALSE:对应基值false的Boolean对象"></a>FALSE:对应基值false的Boolean对象</h4><h4 id="TYPE-基本类型boolean的Class对象"><a href="#TYPE-基本类型boolean的Class对象" class="headerlink" title="TYPE:基本类型boolean的Class对象"></a>TYPE:基本类型boolean的Class对象</h4><hr><hr><h2 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h2><h3 id="定义-Byte类将基本类型为byte的值包装在一个对象中-一个Byte类型的对象只包含一个类型为byte的字段-此外-该类还在byte和String的相互转换提供了方法-并提供了其他一些处理byte时非常有用的常量和方法"><a href="#定义-Byte类将基本类型为byte的值包装在一个对象中-一个Byte类型的对象只包含一个类型为byte的字段-此外-该类还在byte和String的相互转换提供了方法-并提供了其他一些处理byte时非常有用的常量和方法" class="headerlink" title="定义:Byte类将基本类型为byte的值包装在一个对象中,一个Byte类型的对象只包含一个类型为byte的字段.此外,该类还在byte和String的相互转换提供了方法,并提供了其他一些处理byte时非常有用的常量和方法"></a>定义:Byte类将基本类型为byte的值包装在一个对象中,一个Byte类型的对象只包含一个类型为byte的字段.此外,该类还在byte和String的相互转换提供了方法,并提供了其他一些处理byte时非常有用的常量和方法</h3><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="Byte-byte-value-通过这种方法创建的Byte对象，可发现指定的byte值"><a href="#Byte-byte-value-通过这种方法创建的Byte对象，可发现指定的byte值" class="headerlink" title="Byte(byte value)//通过这种方法创建的Byte对象，可发现指定的byte值"></a><code>Byte(byte value)</code>//通过这种方法创建的Byte对象，可发现指定的byte值</h4><h4 id="Byte-String-str-通过这种方法创建的Byte对象，可表示指定的byte值"><a href="#Byte-String-str-通过这种方法创建的Byte对象，可表示指定的byte值" class="headerlink" title="Byte(String str)//通过这种方法创建的Byte对象，可表示指定的byte值"></a><code>Byte(String str)</code>//通过这种方法创建的Byte对象，可表示指定的byte值</h4><h4 id="要用数值型String变量作为参数，如123，否则将会抛出NumberForFormatException异常"><a href="#要用数值型String变量作为参数，如123，否则将会抛出NumberForFormatException异常" class="headerlink" title="要用数值型String变量作为参数，如123，否则将会抛出NumberForFormatException异常"></a>要用数值型String变量作为参数，如123，否则将会抛出NumberForFormatException异常</h4><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="byteValue-1"><a href="#byteValue-1" class="headerlink" title="byteValue()"></a><code>byteValue()</code></h4><h5 id="byte-以一个byte值返回Byte"><a href="#byte-以一个byte值返回Byte" class="headerlink" title="byte:以一个byte值返回Byte"></a>byte:以一个byte值返回Byte</h5><h4 id="compareTo-Byte-anotherByte"><a href="#compareTo-Byte-anotherByte" class="headerlink" title="compareTo(Byte anotherByte)"></a><code>compareTo(Byte anotherByte)</code></h4><h5 id="int-在数字上比较两个Byte对象"><a href="#int-在数字上比较两个Byte对象" class="headerlink" title="int:在数字上比较两个Byte对象"></a>int:在数字上比较两个Byte对象</h5><h4 id="doubleValue"><a href="#doubleValue" class="headerlink" title="doubleValue()"></a><code>doubleValue()</code></h4><h5 id="double-以一个double值返回此Byte的值"><a href="#double-以一个double值返回此Byte的值" class="headerlink" title="double:以一个double值返回此Byte的值"></a>double:以一个double值返回此Byte的值</h5><h4 id="intValue-1"><a href="#intValue-1" class="headerlink" title="intValue()"></a><code>intValue()</code></h4><h5 id="int-以一个int值返回此byte的值"><a href="#int-以一个int值返回此byte的值" class="headerlink" title="int:以一个int值返回此byte的值"></a>int:以一个int值返回此byte的值</h5><h4 id="parseByte-String-s"><a href="#parseByte-String-s" class="headerlink" title="parseByte(String s)"></a><code>parseByte(String s)</code></h4><h5 id="byte-将String型参数解析成等价的字节（byte）形式"><a href="#byte-将String型参数解析成等价的字节（byte）形式" class="headerlink" title="byte:将String型参数解析成等价的字节（byte）形式"></a>byte:将String型参数解析成等价的字节（byte）形式</h5><h4 id="toString-1"><a href="#toString-1" class="headerlink" title=" toString()"></a><code> toString()</code></h4><h5 id="String-返回表示此Byte的值的String对象"><a href="#String-返回表示此Byte的值的String对象" class="headerlink" title="String:返回表示此Byte的值的String对象"></a>String:返回表示此Byte的值的String对象</h5><h4 id="valueOf-String-str-1"><a href="#valueOf-String-str-1" class="headerlink" title="valueOf(String str)"></a><code>valueOf(String str)</code></h4><h5 id="byte-返回一个保持指定String所给出的值的Byte对象"><a href="#byte-返回一个保持指定String所给出的值的Byte对象" class="headerlink" title="byte:返回一个保持指定String所给出的值的Byte对象"></a>byte:返回一个保持指定String所给出的值的Byte对象</h5><h4 id="equals-Object-obj-1"><a href="#equals-Object-obj-1" class="headerlink" title="equals(Object obj)"></a><code>equals(Object obj)</code></h4><h5 id="boolean-将此对象与指定对象比较，如果调用该方法的对象与obj相等，返回true，否则返回false"><a href="#boolean-将此对象与指定对象比较，如果调用该方法的对象与obj相等，返回true，否则返回false" class="headerlink" title="boolean:将此对象与指定对象比较，如果调用该方法的对象与obj相等，返回true，否则返回false"></a>boolean:将此对象与指定对象比较，如果调用该方法的对象与obj相等，返回true，否则返回false</h5><h3 id="常量-2"><a href="#常量-2" class="headerlink" title="常量"></a>常量</h3><h4 id="MIN-VALUE-byte类型可取的最小值"><a href="#MIN-VALUE-byte类型可取的最小值" class="headerlink" title="MIN_VALUE:byte类型可取的最小值"></a>MIN_VALUE:byte类型可取的最小值</h4><h4 id="MAX-VALUE-byte类型可取的最大值"><a href="#MAX-VALUE-byte类型可取的最大值" class="headerlink" title="MAX_VALUE:byte类型可取的最大值"></a>MAX_VALUE:byte类型可取的最大值</h4><h4 id="SIZE-用于以二进制补码形式表示byte值的位数"><a href="#SIZE-用于以二进制补码形式表示byte值的位数" class="headerlink" title="SIZE:用于以二进制补码形式表示byte值的位数"></a>SIZE:用于以二进制补码形式表示byte值的位数</h4><h4 id="TYPE-表示基本类型byte的Class实例"><a href="#TYPE-表示基本类型byte的Class实例" class="headerlink" title="TYPE:表示基本类型byte的Class实例"></a>TYPE:表示基本类型byte的Class实例</h4><hr><hr><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><h3 id="定义-Character类在对象中包装一个基本数据类型为char的值-一个Character类型的对象包含类型为char的单个字段-该类提供了几种方法-以确定字符的类别-小写字母-数字类等-并将字符从大写转换成小写-反之亦然"><a href="#定义-Character类在对象中包装一个基本数据类型为char的值-一个Character类型的对象包含类型为char的单个字段-该类提供了几种方法-以确定字符的类别-小写字母-数字类等-并将字符从大写转换成小写-反之亦然" class="headerlink" title="定义:Character类在对象中包装一个基本数据类型为char的值,一个Character类型的对象包含类型为char的单个字段,该类提供了几种方法,以确定字符的类别(小写字母,数字类等),并将字符从大写转换成小写,反之亦然"></a>定义:Character类在对象中包装一个基本数据类型为char的值,一个Character类型的对象包含类型为char的单个字段,该类提供了几种方法,以确定字符的类别(小写字母,数字类等),并将字符从大写转换成小写,反之亦然</h3><h3 id="构造方法-Character-char-value-该类的构造函数必须是一个char类型的数值。通过该函数创建的Character类对象包含由char类型参数提供的值-一旦Character类被创建，它包含的数值就不能改变了。"><a href="#构造方法-Character-char-value-该类的构造函数必须是一个char类型的数值。通过该函数创建的Character类对象包含由char类型参数提供的值-一旦Character类被创建，它包含的数值就不能改变了。" class="headerlink" title="构造方法:Character(char value)//该类的构造函数必须是一个char类型的数值。通过该函数创建的Character类对象包含由char类型参数提供的值,一旦Character类被创建，它包含的数值就不能改变了。"></a>构造方法:<code>Character(char value)</code>//该类的构造函数必须是一个char类型的数值。通过该函数创建的Character类对象包含由char类型参数提供的值,一旦Character类被创建，它包含的数值就不能改变了。</h3><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="charvalue"><a href="#charvalue" class="headerlink" title="charvalue()"></a><code>charvalue()</code></h4><h5 id="char-返回此Character对象的值"><a href="#char-返回此Character对象的值" class="headerlink" title="char:返回此Character对象的值"></a>char:返回此Character对象的值</h5><h4 id="compareTo-Character-anotherCharacter"><a href="#compareTo-Character-anotherCharacter" class="headerlink" title="compareTo(Character anotherCharacter)"></a><code>compareTo(Character anotherCharacter)</code></h4><h5 id="int-根据数字比较两个Character对象，若这两两个对象相等则返回0"><a href="#int-根据数字比较两个Character对象，若这两两个对象相等则返回0" class="headerlink" title="int:根据数字比较两个Character对象，若这两两个对象相等则返回0"></a>int:根据数字比较两个Character对象，若这两两个对象相等则返回0</h5><h4 id="equals-Object-obj-2"><a href="#equals-Object-obj-2" class="headerlink" title="equals(Object obj)"></a><code>equals(Object obj)</code></h4><h5 id="Boolean-将调用该方法的对象与指定的对象相比较"><a href="#Boolean-将调用该方法的对象与指定的对象相比较" class="headerlink" title="Boolean:将调用该方法的对象与指定的对象相比较"></a>Boolean:将调用该方法的对象与指定的对象相比较</h5><h4 id="toUpperCase-char-ch"><a href="#toUpperCase-char-ch" class="headerlink" title="toUpperCase(char ch)"></a><code>toUpperCase(char ch)</code></h4><h5 id="char-将字符参数转换为大写"><a href="#char-将字符参数转换为大写" class="headerlink" title="char:将字符参数转换为大写"></a>char:将字符参数转换为大写</h5><h4 id="toLowerCase-char-ch"><a href="#toLowerCase-char-ch" class="headerlink" title="toLowerCase(char ch)"></a><code>toLowerCase(char ch)</code></h4><h5 id="char-将字符参数转换为小写"><a href="#char-将字符参数转换为小写" class="headerlink" title="char:将字符参数转换为小写"></a>char:将字符参数转换为小写</h5><h4 id="toString-2"><a href="#toString-2" class="headerlink" title="toString()"></a><code>toString()</code></h4><h5 id="String-返回一个表示指定char值的String对象"><a href="#String-返回一个表示指定char值的String对象" class="headerlink" title="String:返回一个表示指定char值的String对象"></a>String:返回一个表示指定char值的String对象</h5><h4 id="charValue"><a href="#charValue" class="headerlink" title="charValue()"></a><code>charValue()</code></h4><h5 id="char-返回此Character对象的值-1"><a href="#char-返回此Character对象的值-1" class="headerlink" title="char:返回此Character对象的值"></a>char:返回此Character对象的值</h5><h4 id="isUpperCase-char-ch"><a href="#isUpperCase-char-ch" class="headerlink" title="isUpperCase(char ch)"></a><code>isUpperCase(char ch)</code></h4><h5 id="boolean-判断指定字符是否为大写字符"><a href="#boolean-判断指定字符是否为大写字符" class="headerlink" title="boolean:判断指定字符是否为大写字符"></a>boolean:判断指定字符是否为大写字符</h5><h4 id="isLowerCase-char-ch"><a href="#isLowerCase-char-ch" class="headerlink" title="isLowerCase(char ch)"></a><code>isLowerCase(char ch)</code></h4><h5 id="boolean-判断指定字符是否为小写字符"><a href="#boolean-判断指定字符是否为小写字符" class="headerlink" title="boolean:判断指定字符是否为小写字符"></a>boolean:判断指定字符是否为小写字符</h5><h3 id="常量-3"><a href="#常量-3" class="headerlink" title="常量"></a>常量</h3><h4 id="CONNECTOR-PUNCTUATION-返回byte型值，表示Unicode规范中的常规类别“Pc”"><a href="#CONNECTOR-PUNCTUATION-返回byte型值，表示Unicode规范中的常规类别“Pc”" class="headerlink" title="CONNECTOR_PUNCTUATION:返回byte型值，表示Unicode规范中的常规类别“Pc”"></a>CONNECTOR_PUNCTUATION:返回byte型值，表示Unicode规范中的常规类别“Pc”</h4><h4 id="UNASSIGNED-返回byte型值，表示Unicode规范中的常规类别“Cn”"><a href="#UNASSIGNED-返回byte型值，表示Unicode规范中的常规类别“Cn”" class="headerlink" title="UNASSIGNED:返回byte型值，表示Unicode规范中的常规类别“Cn”"></a>UNASSIGNED:返回byte型值，表示Unicode规范中的常规类别“Cn”</h4><h4 id="TITLECASE-LETTER-返回byte型值，表示Unicode规范中的常规类别“Lt”"><a href="#TITLECASE-LETTER-返回byte型值，表示Unicode规范中的常规类别“Lt”" class="headerlink" title="TITLECASE_LETTER:返回byte型值，表示Unicode规范中的常规类别“Lt”"></a>TITLECASE_LETTER:返回byte型值，表示Unicode规范中的常规类别“Lt”</h4><hr><hr><h2 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h4 id="Double和Float包装类是对double-float基本类型的封装-它们都是Number类的子类-又都是小数进行操作-所以常用方法基本相同"><a href="#Double和Float包装类是对double-float基本类型的封装-它们都是Number类的子类-又都是小数进行操作-所以常用方法基本相同" class="headerlink" title="Double和Float包装类是对double,float基本类型的封装,它们都是Number类的子类,又都是小数进行操作,所以常用方法基本相同,"></a>Double和Float包装类是对double,float基本类型的封装,它们都是Number类的子类,又都是小数进行操作,所以常用方法基本相同,</h4><h4 id="Double类在对象中包装一个基本类型为double的值-每个Double类的对象都包含一个double类型的字段-此外-该类还提供多个方法-可以将double转换为String-也可以将String转换为double-也提供了其他一些处理double时有用的常量和方法"><a href="#Double类在对象中包装一个基本类型为double的值-每个Double类的对象都包含一个double类型的字段-此外-该类还提供多个方法-可以将double转换为String-也可以将String转换为double-也提供了其他一些处理double时有用的常量和方法" class="headerlink" title="Double类在对象中包装一个基本类型为double的值,每个Double类的对象都包含一个double类型的字段,此外,该类还提供多个方法,可以将double转换为String,也可以将String转换为double,也提供了其他一些处理double时有用的常量和方法"></a>Double类在对象中包装一个基本类型为double的值,每个Double类的对象都包含一个double类型的字段,此外,该类还提供多个方法,可以将double转换为String,也可以将String转换为double,也提供了其他一些处理double时有用的常量和方法</h4><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="Double-double-value-基于double参数创建Double类对象"><a href="#Double-double-value-基于double参数创建Double类对象" class="headerlink" title="Double(double value):基于double参数创建Double类对象"></a>Double(double value):基于double参数创建Double类对象</h4><h4 id="Double-String-str-构造一个新分配的Double对象，表示用字符串表示的double类型的浮点值"><a href="#Double-String-str-构造一个新分配的Double对象，表示用字符串表示的double类型的浮点值" class="headerlink" title="Double(String str):构造一个新分配的Double对象，表示用字符串表示的double类型的浮点值"></a>Double(String str):构造一个新分配的Double对象，表示用字符串表示的double类型的浮点值</h4><h4 id="如果不是以数值类型的字符串作为参数，则抛出NumberFormatException异常"><a href="#如果不是以数值类型的字符串作为参数，则抛出NumberFormatException异常" class="headerlink" title="如果不是以数值类型的字符串作为参数，则抛出NumberFormatException异常"></a>如果不是以数值类型的字符串作为参数，则抛出NumberFormatException异常</h4><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="byteValue-2"><a href="#byteValue-2" class="headerlink" title="byteValue()"></a><code>byteValue()</code></h4><h5 id="byte-以byte形式返回Double对象值（通过强制转换）"><a href="#byte-以byte形式返回Double对象值（通过强制转换）" class="headerlink" title="byte:以byte形式返回Double对象值（通过强制转换）"></a>byte:以byte形式返回Double对象值（通过强制转换）</h5><h4 id="compareTo-Double-d"><a href="#compareTo-Double-d" class="headerlink" title="compareTo(Double d)"></a><code>compareTo(Double d)</code></h4><h5 id="int-对两个Double对象进行数值比较。如果两个值相等，则返回0；如果调用对象的数值小于-d的数值，则返回负值；如果调用对象的数值大于d的值，则返回正值"><a href="#int-对两个Double对象进行数值比较。如果两个值相等，则返回0；如果调用对象的数值小于-d的数值，则返回负值；如果调用对象的数值大于d的值，则返回正值" class="headerlink" title="int:对两个Double对象进行数值比较。如果两个值相等，则返回0；如果调用对象的数值小于 d的数值，则返回负值；如果调用对象的数值大于d的值，则返回正值"></a>int:对两个Double对象进行数值比较。如果两个值相等，则返回0；如果调用对象的数值小于 d的数值，则返回负值；如果调用对象的数值大于d的值，则返回正值</h5><h4 id="equals-Object-obj-3"><a href="#equals-Object-obj-3" class="headerlink" title="equals(Object obj)"></a><code>equals(Object obj)</code></h4><h5 id="boolean-将此对象与指定的对象相比较"><a href="#boolean-将此对象与指定的对象相比较" class="headerlink" title="boolean:将此对象与指定的对象相比较"></a>boolean:将此对象与指定的对象相比较</h5><h4 id="intValue-2"><a href="#intValue-2" class="headerlink" title="intValue()"></a><code>intValue()</code></h4><h5 id="int-以int形式返回double的值"><a href="#int-以int形式返回double的值" class="headerlink" title="int:以int形式返回double的值"></a>int:以int形式返回double的值</h5><h4 id="isNaN"><a href="#isNaN" class="headerlink" title=" isNaN()"></a><code> isNaN()</code></h4><h5 id="boolean-如果此double值是非数字（NaN）值，则返回true-否则返回false"><a href="#boolean-如果此double值是非数字（NaN）值，则返回true-否则返回false" class="headerlink" title="boolean:如果此double值是非数字（NaN）值，则返回true;否则返回false"></a>boolean:如果此double值是非数字（NaN）值，则返回true;否则返回false</h5><h4 id="toString-3"><a href="#toString-3" class="headerlink" title="toString()"></a><code>toString()</code></h4><h5 id="String-返回此double对象的字符串表示形式"><a href="#String-返回此double对象的字符串表示形式" class="headerlink" title="String:返回此double对象的字符串表示形式"></a>String:返回此double对象的字符串表示形式</h5><h4 id="valueOf-String-str-2"><a href="#valueOf-String-str-2" class="headerlink" title="valueOf(String str)"></a><code>valueOf(String str)</code></h4><h5 id="Double-返回保存用参数子符串str表示的double值的double对象"><a href="#Double-返回保存用参数子符串str表示的double值的double对象" class="headerlink" title="Double:返回保存用参数子符串str表示的double值的double对象"></a>Double:返回保存用参数子符串str表示的double值的double对象</h5><h4 id="doubleValue-1"><a href="#doubleValue-1" class="headerlink" title="doubleValue()"></a><code>doubleValue()</code></h4><h5 id="double-以double形式返回此double对象"><a href="#double-以double形式返回此double对象" class="headerlink" title="double:以double形式返回此double对象"></a>double:以double形式返回此double对象</h5><h4 id="longValue"><a href="#longValue" class="headerlink" title="longValue()"></a><code>longValue()</code></h4><h5 id="long-以long形式返回此double的值（通过强制转换为long类型）"><a href="#long-以long形式返回此double的值（通过强制转换为long类型）" class="headerlink" title="long:以long形式返回此double的值（通过强制转换为long类型）"></a>long:以long形式返回此double的值（通过强制转换为long类型）</h5><h3 id="常量-4"><a href="#常量-4" class="headerlink" title="常量"></a>常量</h3><h4 id="MAX-EXPONENT-返回int值，表示有限double变量可能具有的最大指数"><a href="#MAX-EXPONENT-返回int值，表示有限double变量可能具有的最大指数" class="headerlink" title="MAX_EXPONENT:返回int值，表示有限double变量可能具有的最大指数"></a>MAX_EXPONENT:返回int值，表示有限double变量可能具有的最大指数</h4><h4 id="MIN-EXPONENT-返回int值，表示标准化double变量可能具有的最小指数"><a href="#MIN-EXPONENT-返回int值，表示标准化double变量可能具有的最小指数" class="headerlink" title="MIN_EXPONENT:返回int值，表示标准化double变量可能具有的最小指数"></a>MIN_EXPONENT:返回int值，表示标准化double变量可能具有的最小指数</h4><h4 id="NEGATIVE-INFINITY-返回double值，表示保存double类型的负无穷大值的常量"><a href="#NEGATIVE-INFINITY-返回double值，表示保存double类型的负无穷大值的常量" class="headerlink" title="NEGATIVE_INFINITY:返回double值，表示保存double类型的负无穷大值的常量"></a>NEGATIVE_INFINITY:返回double值，表示保存double类型的负无穷大值的常量</h4><h4 id="POSITIVE-INFINITY-返回double值，表示保存double类型的正无穷大值的常量"><a href="#POSITIVE-INFINITY-返回double值，表示保存double类型的正无穷大值的常量" class="headerlink" title="POSITIVE_INFINITY:返回double值，表示保存double类型的正无穷大值的常量"></a>POSITIVE_INFINITY:返回double值，表示保存double类型的正无穷大值的常量</h4><hr><hr><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="定义-抽象类Number是BigDecimal-BigInteger-Byte-Double-Float-Integer-Long和Short类的父类-Number的子类必须提供将表示的数值转换为byte-double-float-int-long和short的方法-也就是说Number的方法子类全部都有"><a href="#定义-抽象类Number是BigDecimal-BigInteger-Byte-Double-Float-Integer-Long和Short类的父类-Number的子类必须提供将表示的数值转换为byte-double-float-int-long和short的方法-也就是说Number的方法子类全部都有" class="headerlink" title="定义:抽象类Number是BigDecimal,BigInteger,Byte,Double,Float,Integer,Long和Short类的父类,Number的子类必须提供将表示的数值转换为byte,double,float,int,long和short的方法.也就是说Number的方法子类全部都有"></a>定义:抽象类Number是BigDecimal,BigInteger,Byte,Double,Float,Integer,Long和Short类的父类,Number的子类必须提供将表示的数值转换为byte,double,float,int,long和short的方法.也就是说Number的方法子类全部都有</h3><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="byteValue-intValue-floatValue-浮点值-shortValue-longValue-doubleValue-双精度值-以什么形式返回指定的数值"><a href="#byteValue-intValue-floatValue-浮点值-shortValue-longValue-doubleValue-双精度值-以什么形式返回指定的数值" class="headerlink" title="byteValue() ,intValue() ,floatValue(浮点值) ,shortValue() ,longValue() ,doubleValue()[双精度值]:以什么形式返回指定的数值"></a>byteValue() ,intValue() ,floatValue(浮点值) ,shortValue() ,longValue() ,doubleValue()[双精度值]:以什么形式返回指定的数值</h4><hr><hr><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Exercise</span></span>&#123;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;练习1:创建Integer类对象,并以int类型将Integer的值返回.&quot;</span>);</span><br><span class="line">int a = <span class="keyword">new</span> Integer(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span>+a);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;练习2:创建两个Character对象,通过equal()比较它们是否相等&quot;</span>+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;之后将这两个对象分别转换成小写形式,再通过equal()方法比较两个Character对象是否相等。&quot;</span>);</span><br><span class="line">Character char1 = <span class="keyword">new</span> Character(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Character char2 = <span class="keyword">new</span> Character(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">System.out.println(char1+<span class="string">&quot;等于&quot;</span>+char2:+<span class="string">&quot;:&quot;</span>+ char1.equals(char2));</span><br><span class="line">Character c1 = Character.toLowerCase(char1);</span><br><span class="line">Character c2 = Character.toLowerCase(char2);</span><br><span class="line">System.out.println(Character.toLowerCase(char1)+<span class="string">&quot;等于&quot;</span>+Character.toLowerCase(char2)+<span class="string">&quot;:&quot;</span>+c1.equals(c2));</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;练习3:实现通过字符型变量创建boolean值，再将其转换成字符串输出，&quot;</span>+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;观察输出后的字符串与创建Boolean对象时给定的参数是否相同。&quot;</span>);</span><br><span class="line">Character c3 = <span class="keyword">new</span> Character(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">String</span> str1 = c3.toString();</span><br><span class="line"><span class="built_in">Boolean</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(str1);</span><br><span class="line"><span class="built_in">String</span> str2 = bool.toString();</span><br><span class="line">System.out.println(<span class="string">&quot;输入的字符型是:&quot;</span>+c3+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;输出的字符串是:&quot;</span>+str2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/14/java%E5%8C%85%E8%A3%85%E7%B1%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java类和对象</title>
      <link>http://example.com/2021/06/13/java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</link>
      <guid>http://example.com/2021/06/13/java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</guid>
      <pubDate>Sun, 13 Jun 2021 12:21:13 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><span id="more"></span><h1 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h1><h2 id="面向对象设计实质上就是对现实世界的对象进行建模操作"><a href="#面向对象设计实质上就是对现实世界的对象进行建模操作" class="headerlink" title="面向对象设计实质上就是对现实世界的对象进行建模操作."></a>面向对象设计实质上就是对现实世界的对象进行建模操作.</h2><h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><h3 id="实质上可以将类看作是对象的载体-它定义了对象所具有的功能"><a href="#实质上可以将类看作是对象的载体-它定义了对象所具有的功能" class="headerlink" title="实质上可以将类看作是对象的载体,它定义了对象所具有的功能"></a>实质上可以将类看作是对象的载体,它定义了对象所具有的功能</h3><h3 id="类是世间事物的抽象称呼-而对象则是这个事物相对应的实体"><a href="#类是世间事物的抽象称呼-而对象则是这个事物相对应的实体" class="headerlink" title="类是世间事物的抽象称呼,而对象则是这个事物相对应的实体."></a>类是世间事物的抽象称呼,而对象则是这个事物相对应的实体.</h3><h3 id="如果面临实际问题-通常需要实例化类对象来解决"><a href="#如果面临实际问题-通常需要实例化类对象来解决" class="headerlink" title="如果面临实际问题,通常需要实例化类对象来解决"></a>如果面临实际问题,通常需要实例化类对象来解决</h3><h3 id="类是封装对象的属性和行为的载体-反过来说具有相同属性和行为的一类实体被成为类-而对象则是类抽象出来的一个实例"><a href="#类是封装对象的属性和行为的载体-反过来说具有相同属性和行为的一类实体被成为类-而对象则是类抽象出来的一个实例" class="headerlink" title="类是封装对象的属性和行为的载体.反过来说具有相同属性和行为的一类实体被成为类,而对象则是类抽象出来的一个实例"></a>类是封装对象的属性和行为的载体.反过来说具有相同属性和行为的一类实体被成为类,而对象则是类抽象出来的一个实例</h3><h3 id="类中对象的行为是以方法的形式定义的-对象的属性是以成员变量的形式定义的-而类包括对象的属性和方法"><a href="#类中对象的行为是以方法的形式定义的-对象的属性是以成员变量的形式定义的-而类包括对象的属性和方法" class="headerlink" title="类中对象的行为是以方法的形式定义的,对象的属性是以成员变量的形式定义的,而类包括对象的属性和方法"></a>类中对象的行为是以方法的形式定义的,对象的属性是以成员变量的形式定义的,而类包括对象的属性和方法</h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><h5 id="是面向对象的核心思想"><a href="#是面向对象的核心思想" class="headerlink" title="是面向对象的核心思想"></a>是面向对象的核心思想</h5><h5 id="将对象的属性和行为封装起来-其载体就是类-类通过对客户隐藏其实现细节"><a href="#将对象的属性和行为封装起来-其载体就是类-类通过对客户隐藏其实现细节" class="headerlink" title="将对象的属性和行为封装起来,其载体就是类,类通过对客户隐藏其实现细节."></a>将对象的属性和行为封装起来,其载体就是类,类通过对客户隐藏其实现细节.</h5><h5 id="采用封装的思想保证了类内部数据结构的完整性-应用该类的的用户不能轻易地直接操作此数据结构-只能执行类允许公开的数据"><a href="#采用封装的思想保证了类内部数据结构的完整性-应用该类的的用户不能轻易地直接操作此数据结构-只能执行类允许公开的数据" class="headerlink" title="采用封装的思想保证了类内部数据结构的完整性,应用该类的的用户不能轻易地直接操作此数据结构,只能执行类允许公开的数据."></a>采用封装的思想保证了类内部数据结构的完整性,应用该类的的用户不能轻易地直接操作此数据结构,只能执行类允许公开的数据.</h5><h6 id="这样就避免了外部操作对内部数据的影响-提高了程序的可维护性"><a href="#这样就避免了外部操作对内部数据的影响-提高了程序的可维护性" class="headerlink" title="这样就避免了外部操作对内部数据的影响,提高了程序的可维护性."></a>这样就避免了外部操作对内部数据的影响,提高了程序的可维护性.</h6><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="思想-当处理一个问题时-可以将一些有用的类保留下来-在遇到同样问题时拿来复用"><a href="#思想-当处理一个问题时-可以将一些有用的类保留下来-在遇到同样问题时拿来复用" class="headerlink" title="思想:当处理一个问题时,可以将一些有用的类保留下来,在遇到同样问题时拿来复用."></a>思想:当处理一个问题时,可以将一些有用的类保留下来,在遇到同样问题时拿来复用.</h4><h5 id="可见设计软件的代码时使用继承思想可以缩短软件开发的时间-复用那些已经定义好的类可以提高系统性能-减少系统在使用过程中出现错误的机率"><a href="#可见设计软件的代码时使用继承思想可以缩短软件开发的时间-复用那些已经定义好的类可以提高系统性能-减少系统在使用过程中出现错误的机率" class="headerlink" title="可见设计软件的代码时使用继承思想可以缩短软件开发的时间,复用那些已经定义好的类可以提高系统性能,减少系统在使用过程中出现错误的机率."></a>可见设计软件的代码时使用继承思想可以缩短软件开发的时间,复用那些已经定义好的类可以提高系统性能,减少系统在使用过程中出现错误的机率.</h5><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><h5 id="其实将父类对象应用于子类的特征就是多态"><a href="#其实将父类对象应用于子类的特征就是多态" class="headerlink" title="其实将父类对象应用于子类的特征就是多态"></a>其实将父类对象应用于子类的特征就是多态</h5><h5 id="多态性允许以统一的风格编写程序-以处理种类繁多的已存在的类及相关类-该统一的风格可以由父类来实现-根据父类统一风格的处理-可以实例化子类的对象-由于整个事件的处理都只依赖于父类的方法-所以日后只要维护和调整父类的方法即可-这样就降低了维护的难度-节省了时间"><a href="#多态性允许以统一的风格编写程序-以处理种类繁多的已存在的类及相关类-该统一的风格可以由父类来实现-根据父类统一风格的处理-可以实例化子类的对象-由于整个事件的处理都只依赖于父类的方法-所以日后只要维护和调整父类的方法即可-这样就降低了维护的难度-节省了时间" class="headerlink" title="多态性允许以统一的风格编写程序,以处理种类繁多的已存在的类及相关类.该统一的风格可以由父类来实现,根据父类统一风格的处理,可以实例化子类的对象.由于整个事件的处理都只依赖于父类的方法,所以日后只要维护和调整父类的方法即可,这样就降低了维护的难度,节省了时间."></a>多态性允许以统一的风格编写程序,以处理种类繁多的已存在的类及相关类.该统一的风格可以由父类来实现,根据父类统一风格的处理,可以实例化子类的对象.由于整个事件的处理都只依赖于父类的方法,所以日后只要维护和调整父类的方法即可,这样就降低了维护的难度,节省了时间.</h5><h5 id="多态的实现并不依赖具体类-而是依赖于抽象类和接口"><a href="#多态的实现并不依赖具体类-而是依赖于抽象类和接口" class="headerlink" title="多态的实现并不依赖具体类,而是依赖于抽象类和接口"></a>多态的实现并不依赖具体类,而是依赖于抽象类和接口</h5><h5 id="在多态的机制中-比抽象类更方便的方式是将抽象类定义为接口"><a href="#在多态的机制中-比抽象类更方便的方式是将抽象类定义为接口" class="headerlink" title="在多态的机制中,比抽象类更方便的方式是将抽象类定义为接口"></a>在多态的机制中,比抽象类更方便的方式是将抽象类定义为接口</h5><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><h4 id="Java中对象的属性"><a href="#Java中对象的属性" class="headerlink" title="Java中对象的属性"></a>Java中对象的属性</h4><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="权限修饰符-返回值类型-方法名-参数类型-参数名-方法体-return-返回值"><a href="#权限修饰符-返回值类型-方法名-参数类型-参数名-方法体-return-返回值" class="headerlink" title="权限修饰符 返回值类型 方法名(参数类型 参数名){//方法体; return 返回值;}"></a><code>权限修饰符 返回值类型 方法名(参数类型 参数名)&#123;//方法体; return 返回值;&#125;</code></h4><h4 id="Java中的成员无返回值可以使用void关键字表示-有的话要与方法返回的值类型一致"><a href="#Java中的成员无返回值可以使用void关键字表示-有的话要与方法返回的值类型一致" class="headerlink" title="Java中的成员无返回值可以使用void关键字表示,有的话要与方法返回的值类型一致"></a>Java中的成员无返回值可以使用void关键字表示,有的话要与方法返回的值类型一致</h4><h4 id="如果一个方法中含有与成员变量同名的局部变量-则方法中对这个变量的访问以局部变量进行"><a href="#如果一个方法中含有与成员变量同名的局部变量-则方法中对这个变量的访问以局部变量进行" class="headerlink" title="如果一个方法中含有与成员变量同名的局部变量,则方法中对这个变量的访问以局部变量进行."></a>如果一个方法中含有与成员变量同名的局部变量,则方法中对这个变量的访问以局部变量进行.</h4><h4 id="类成员变量和类成员方法也可以统称为类成员"><a href="#类成员变量和类成员方法也可以统称为类成员" class="headerlink" title="类成员变量和类成员方法也可以统称为类成员"></a>类成员变量和类成员方法也可以统称为类成员</h4><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><h4 id="private-只能在本类中使用-在子类中是不可见的-并且对其他包的类是不可见的"><a href="#private-只能在本类中使用-在子类中是不可见的-并且对其他包的类是不可见的" class="headerlink" title="private:只能在本类中使用,在子类中是不可见的,并且对其他包的类是不可见的"></a>private:只能在本类中使用,在子类中是不可见的,并且对其他包的类是不可见的</h4><h4 id="public-除了在本类中使用外-还可以在子类和其他包的类中使用"><a href="#public-除了在本类中使用外-还可以在子类和其他包的类中使用" class="headerlink" title="public:除了在本类中使用外,还可以在子类和其他包的类中使用."></a>public:除了在本类中使用外,还可以在子类和其他包的类中使用.</h4><h4 id="protected-本包内的该类的子类和其他类可以访问"><a href="#protected-本包内的该类的子类和其他类可以访问" class="headerlink" title="protected:本包内的该类的子类和其他类可以访问."></a>protected:本包内的该类的子类和其他类可以访问.</h4><h4 id="当声明类时不使用public、protected和private修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。"><a href="#当声明类时不使用public、protected和private修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。" class="headerlink" title="当声明类时不使用public、protected和private修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。"></a>当声明类时不使用public、protected和private修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。</h4><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="方法内的变量"><a href="#方法内的变量" class="headerlink" title="方法内的变量"></a>方法内的变量</h4><h4 id="是在方法被创建时创建-在方法执行结束后销毁-作用域也在这期间-在互相不嵌套的作用域中可以同时声明两个名称和内容相同的局部变量"><a href="#是在方法被创建时创建-在方法执行结束后销毁-作用域也在这期间-在互相不嵌套的作用域中可以同时声明两个名称和内容相同的局部变量" class="headerlink" title="是在方法被创建时创建,在方法执行结束后销毁.作用域也在这期间,在互相不嵌套的作用域中可以同时声明两个名称和内容相同的局部变量."></a>是在方法被创建时创建,在方法执行结束后销毁.作用域也在这期间,在互相不嵌套的作用域中可以同时声明两个名称和内容相同的局部变量.</h4><h4 id="在作用域范围外使用局部变量是一个常见的错误-因为在作用范围外没有声明局部变量的代码"><a href="#在作用域范围外使用局部变量是一个常见的错误-因为在作用范围外没有声明局部变量的代码" class="headerlink" title="在作用域范围外使用局部变量是一个常见的错误,因为在作用范围外没有声明局部变量的代码."></a>在作用域范围外使用局部变量是一个常见的错误,因为在作用范围外没有声明局部变量的代码.</h4><h4 id="在使用时必须进行赋值操作或被初始化-否则会出现编译错误"><a href="#在使用时必须进行赋值操作或被初始化-否则会出现编译错误" class="headerlink" title="在使用时必须进行赋值操作或被初始化,否则会出现编译错误"></a>在使用时必须进行赋值操作或被初始化,否则会出现编译错误</h4><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><h4 id="在Java语言中规定使用this关键字来代表苯类对象的引用-this关键字被隐式的用于引用对象的成员变量和方法"><a href="#在Java语言中规定使用this关键字来代表苯类对象的引用-this关键字被隐式的用于引用对象的成员变量和方法" class="headerlink" title="在Java语言中规定使用this关键字来代表苯类对象的引用,this关键字被隐式的用于引用对象的成员变量和方法."></a>在Java语言中规定使用this关键字来代表苯类对象的引用,this关键字被隐式的用于引用对象的成员变量和方法.</h4><h4 id="this除了可以调用成员变量或成员方法之外-还可以作为方法的返回值"><a href="#this除了可以调用成员变量或成员方法之外-还可以作为方法的返回值" class="headerlink" title="this除了可以调用成员变量或成员方法之外,还可以作为方法的返回值"></a>this除了可以调用成员变量或成员方法之外,还可以作为方法的返回值</h4><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><h3 id="定义-在类中除了成员方法之外-还存在一种特殊类型的方法-那就是构造方法-是一个与类同名的方法-对象的创建就是通过构造方法完成的-每当类实例化一个对象时-类都会自动调用构造方法"><a href="#定义-在类中除了成员方法之外-还存在一种特殊类型的方法-那就是构造方法-是一个与类同名的方法-对象的创建就是通过构造方法完成的-每当类实例化一个对象时-类都会自动调用构造方法" class="headerlink" title="定义:在类中除了成员方法之外,还存在一种特殊类型的方法,那就是构造方法,是一个与类同名的方法,对象的创建就是通过构造方法完成的.每当类实例化一个对象时,类都会自动调用构造方法"></a>定义:在类中除了成员方法之外,还存在一种特殊类型的方法,那就是构造方法,是一个与类同名的方法,对象的创建就是通过构造方法完成的.每当类实例化一个对象时,类都会自动调用构造方法</h3><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><h4 id="构造方法没有返回值"><a href="#构造方法没有返回值" class="headerlink" title="构造方法没有返回值"></a>构造方法没有返回值</h4><h4 id="构造方法的名称要与本类的名称相同"><a href="#构造方法的名称要与本类的名称相同" class="headerlink" title="构造方法的名称要与本类的名称相同"></a>构造方法的名称要与本类的名称相同</h4><h4 id="在定义构造方法时，构造方法没有返回值，但这与普通没有返回值的方法不同，普通没有返回值的方法使用public-void-methodEx-这种形式进行定义但构造方法并不需要使用void关键字修饰"><a href="#在定义构造方法时，构造方法没有返回值，但这与普通没有返回值的方法不同，普通没有返回值的方法使用public-void-methodEx-这种形式进行定义但构造方法并不需要使用void关键字修饰" class="headerlink" title="在定义构造方法时，构造方法没有返回值，但这与普通没有返回值的方法不同，普通没有返回值的方法使用public void methodEx()这种形式进行定义但构造方法并不需要使用void关键字修饰"></a>在定义构造方法时，构造方法没有返回值，但这与普通没有返回值的方法不同，普通没有返回值的方法使用public void methodEx()这种形式进行定义但构造方法并不需要使用void关键字修饰</h4><h3 id="在构造方法中可以为成员变量赋值-这样实例化一个本类的对象时-相应的成员变量也将被初始化"><a href="#在构造方法中可以为成员变量赋值-这样实例化一个本类的对象时-相应的成员变量也将被初始化" class="headerlink" title="在构造方法中可以为成员变量赋值,这样实例化一个本类的对象时,相应的成员变量也将被初始化"></a>在构造方法中可以为成员变量赋值,这样实例化一个本类的对象时,相应的成员变量也将被初始化</h3><h3 id="如果类中没有明确定义-系统会默认一个空的构造方法"><a href="#如果类中没有明确定义-系统会默认一个空的构造方法" class="headerlink" title="如果类中没有明确定义,系统会默认一个空的构造方法"></a>如果类中没有明确定义,系统会默认一个空的构造方法</h3><h4 id="如果在类中定义的构造方法都不是无参的构造方法，那么编译器也不会为类设置一个默认的无参构造方法，当试图调用无参构造方法实例化一个对象时，编译器会报错，所以只有在类中没有定义任何构造方法时，编译器才会在该类中自动创建一个不带参数的构造方法"><a href="#如果在类中定义的构造方法都不是无参的构造方法，那么编译器也不会为类设置一个默认的无参构造方法，当试图调用无参构造方法实例化一个对象时，编译器会报错，所以只有在类中没有定义任何构造方法时，编译器才会在该类中自动创建一个不带参数的构造方法" class="headerlink" title="如果在类中定义的构造方法都不是无参的构造方法，那么编译器也不会为类设置一个默认的无参构造方法，当试图调用无参构造方法实例化一个对象时，编译器会报错，所以只有在类中没有定义任何构造方法时，编译器才会在该类中自动创建一个不带参数的构造方法"></a>如果在类中定义的构造方法都不是无参的构造方法，那么编译器也不会为类设置一个默认的无参构造方法，当试图调用无参构造方法实例化一个对象时，编译器会报错，所以只有在类中没有定义任何构造方法时，编译器才会在该类中自动创建一个不带参数的构造方法</h4><h2 id="静态变量、常量和方法"><a href="#静态变量、常量和方法" class="headerlink" title="静态变量、常量和方法"></a>静态变量、常量和方法</h2><h3 id="可以使处理问题时会需要两个类在同一个内存区域共享一个数据"><a href="#可以使处理问题时会需要两个类在同一个内存区域共享一个数据" class="headerlink" title="可以使处理问题时会需要两个类在同一个内存区域共享一个数据"></a>可以使处理问题时会需要两个类在同一个内存区域共享一个数据</h3><h3 id="被声明为static的变量、常量和方法被称为静态成员、静态成员属于类所有，区别于个别对象，可以在本类或其他类使用类名和“-”运算符调用静态成员"><a href="#被声明为static的变量、常量和方法被称为静态成员、静态成员属于类所有，区别于个别对象，可以在本类或其他类使用类名和“-”运算符调用静态成员" class="headerlink" title="被声明为static的变量、常量和方法被称为静态成员、静态成员属于类所有，区别于个别对象，可以在本类或其他类使用类名和“.”运算符调用静态成员"></a>被声明为static的变量、常量和方法被称为静态成员、静态成员属于类所有，区别于个别对象，可以在本类或其他类使用类名和“.”运算符调用静态成员</h3><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="类名-静态成员"><a href="#类名-静态成员" class="headerlink" title="类名.静态成员"></a>类名.静态成员</h4><h4 id="可以使用以上这种形式进行调用，但通常不建议用这样的形式，因为这样容易混淆静态成员和非静态成员"><a href="#可以使用以上这种形式进行调用，但通常不建议用这样的形式，因为这样容易混淆静态成员和非静态成员" class="headerlink" title="可以使用以上这种形式进行调用，但通常不建议用这样的形式，因为这样容易混淆静态成员和非静态成员"></a>可以使用以上这种形式进行调用，但通常不建议用这样的形式，因为这样容易混淆静态成员和非静态成员</h4><h3 id="作用-通常是为了提供共享数据或方法，虽然类名-静态成员调用比较方便，但静态成员同样遵循着public-private-protected修饰符的约束"><a href="#作用-通常是为了提供共享数据或方法，虽然类名-静态成员调用比较方便，但静态成员同样遵循着public-private-protected修饰符的约束" class="headerlink" title="作用:通常是为了提供共享数据或方法，虽然类名.静态成员调用比较方便，但静态成员同样遵循着public private protected修饰符的约束"></a>作用:通常是为了提供共享数据或方法，虽然类名.静态成员调用比较方便，但静态成员同样遵循着public private protected修饰符的约束</h3><h3 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h3><h4 id="在静态方法中不能使用this关键字"><a href="#在静态方法中不能使用this关键字" class="headerlink" title="在静态方法中不能使用this关键字"></a>在静态方法中不能使用this关键字</h4><h4 id="在静态方法中不能直接调用非静态方法"><a href="#在静态方法中不能直接调用非静态方法" class="headerlink" title="在静态方法中不能直接调用非静态方法"></a>在静态方法中不能直接调用非静态方法</h4><h4 id="不能将方法体内的局部变量声明为static的"><a href="#不能将方法体内的局部变量声明为static的" class="headerlink" title="不能将方法体内的局部变量声明为static的"></a>不能将方法体内的局部变量声明为static的</h4><h3 id="静态区域"><a href="#静态区域" class="headerlink" title="静态区域"></a>静态区域</h3><h4 id="如果在执行类时，希望先执行类的初始化动作，可以使用static定义一个静态区域。"><a href="#如果在执行类时，希望先执行类的初始化动作，可以使用static定义一个静态区域。" class="headerlink" title="如果在执行类时，希望先执行类的初始化动作，可以使用static定义一个静态区域。"></a>如果在执行类时，希望先执行类的初始化动作，可以使用static定义一个静态区域。</h4><h4 id="当这段代码被执行时，首先执行static块中的程序，并且只会执行一次"><a href="#当这段代码被执行时，首先执行static块中的程序，并且只会执行一次" class="headerlink" title="当这段代码被执行时，首先执行static块中的程序，并且只会执行一次"></a>当这段代码被执行时，首先执行static块中的程序，并且只会执行一次</h4><h2 id="类的主方法"><a href="#类的主方法" class="headerlink" title="类的主方法"></a>类的主方法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="主方法是类的入口点，它定义了程序从何处开始；"><a href="#主方法是类的入口点，它定义了程序从何处开始；" class="headerlink" title="主方法是类的入口点，它定义了程序从何处开始；"></a>主方法是类的入口点，它定义了程序从何处开始；</h4><h4 id="主方法提供对程序流向的控制，Java编译器哦那个过主方法来执行程序"><a href="#主方法提供对程序流向的控制，Java编译器哦那个过主方法来执行程序" class="headerlink" title="主方法提供对程序流向的控制，Java编译器哦那个过主方法来执行程序"></a>主方法提供对程序流向的控制，Java编译器哦那个过主方法来执行程序</h4><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="主方法是静态的，所以如要直接在主方法中调用其他方法，则该方法必须也是静态的。"><a href="#主方法是静态的，所以如要直接在主方法中调用其他方法，则该方法必须也是静态的。" class="headerlink" title="主方法是静态的，所以如要直接在主方法中调用其他方法，则该方法必须也是静态的。"></a>主方法是静态的，所以如要直接在主方法中调用其他方法，则该方法必须也是静态的。</h4><h4 id="主方法没有返回值"><a href="#主方法没有返回值" class="headerlink" title="主方法没有返回值"></a>主方法没有返回值</h4><h4 id="主方法的形参为数组。其中args-0-args-n-分别代表程序的第一个参数到第n个参数，可以使用args-length获取参数的个数。"><a href="#主方法的形参为数组。其中args-0-args-n-分别代表程序的第一个参数到第n个参数，可以使用args-length获取参数的个数。" class="headerlink" title="主方法的形参为数组。其中args[0]~args[n]分别代表程序的第一个参数到第n个参数，可以使用args.length获取参数的个数。"></a>主方法的形参为数组。其中args[0]~args[n]分别代表程序的第一个参数到第n个参数，可以使用args.length获取参数的个数。</h4><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="由类抽象出来的，所有的问题都通过对象来处理"><a href="#由类抽象出来的，所有的问题都通过对象来处理" class="headerlink" title="由类抽象出来的，所有的问题都通过对象来处理"></a>由类抽象出来的，所有的问题都通过对象来处理</h3><h3 id="每个对象都是相互独立的，在内存中占据独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成垃圾，由Java虚拟机自带的来及回收机制处理，不能被再被使用"><a href="#每个对象都是相互独立的，在内存中占据独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成垃圾，由Java虚拟机自带的来及回收机制处理，不能被再被使用" class="headerlink" title="每个对象都是相互独立的，在内存中占据独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成垃圾，由Java虚拟机自带的来及回收机制处理，不能被再被使用"></a>每个对象都是相互独立的，在内存中占据独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成垃圾，由Java虚拟机自带的来及回收机制处理，不能被再被使用</h3><h3 id="在Java语言中对象和实例事实上可以通用"><a href="#在Java语言中对象和实例事实上可以通用" class="headerlink" title="在Java语言中对象和实例事实上可以通用"></a>在Java语言中对象和实例事实上可以通用</h3><h3 id="访问对象的属性和行为"><a href="#访问对象的属性和行为" class="headerlink" title="访问对象的属性和行为"></a>访问对象的属性和行为</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferProperty</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用call()方法&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransferProperty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TransferProperty t1 = <span class="keyword">new</span> TransferProperty();<span class="comment">//创建一个对象</span></span><br><span class="line">        TransferProperty t2 = <span class="keyword">new</span> TransferProperty();<span class="comment">//创建另一个对象</span></span><br><span class="line">        t2.i = <span class="number">60</span>;<span class="comment">//将类成员变量赋值为60</span></span><br><span class="line">        <span class="comment">//使用第一个对象调用类成员变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个实例对象调用变量i的结果&quot;</span>+ 他.i++);</span><br><span class="line">        t1.call;<span class="comment">//使用第一个对象调用类成员方法</span></span><br><span class="line">        <span class="comment">//使用第二个对象调用类成员变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二个实例对象调用变量i的结果: &quot;</span>+t2.i);</span><br><span class="line">        t2.call();<span class="comment">//使用第二个对象调用类成员方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用new操作符创建一个对象后，对象-类成员来获取对象的属性行为"><a href="#使用new操作符创建一个对象后，对象-类成员来获取对象的属性行为" class="headerlink" title="使用new操作符创建一个对象后，对象.类成员来获取对象的属性行为"></a>使用new操作符创建一个对象后，对象.类成员来获取对象的属性行为</h4><h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><h4 id="Book-book-new-Book"><a href="#Book-book-new-Book" class="headerlink" title="Book book = new Book();"></a><code>Book book = new Book();</code></h4><h4 id="引用只是存放一个对象的内存地址，并非存放一个对象，严格地说，引用和对象是不同的，但是可以将这种区别忽略，如可以简单地说book是Book类的一个对象，而事实上应该是book包含Book对象的一个引用。"><a href="#引用只是存放一个对象的内存地址，并非存放一个对象，严格地说，引用和对象是不同的，但是可以将这种区别忽略，如可以简单地说book是Book类的一个对象，而事实上应该是book包含Book对象的一个引用。" class="headerlink" title="引用只是存放一个对象的内存地址，并非存放一个对象，严格地说，引用和对象是不同的，但是可以将这种区别忽略，如可以简单地说book是Book类的一个对象，而事实上应该是book包含Book对象的一个引用。"></a>引用只是存放一个对象的内存地址，并非存放一个对象，严格地说，引用和对象是不同的，但是可以将这种区别忽略，如可以简单地说book是Book类的一个对象，而事实上应该是book包含Book对象的一个引用。</h4><h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><h4 id="比较两个对象引用的地址是否相等"><a href="#比较两个对象引用的地址是否相等" class="headerlink" title="== : 比较两个对象引用的地址是否相等"></a>== : 比较两个对象引用的地址是否相等</h4><h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><h5 id="String类中的方法"><a href="#String类中的方法" class="headerlink" title="String类中的方法"></a>String类中的方法</h5><h5 id="用于比较两个对象引用所指的内容是否相等；"><a href="#用于比较两个对象引用所指的内容是否相等；" class="headerlink" title="用于比较两个对象引用所指的内容是否相等；"></a>用于比较两个对象引用所指的内容是否相等；</h5><h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><h5 id="每个对象都有生命周期，当对象的生命周期结束时，分配给该对象的内存地址将会被回收。"><a href="#每个对象都有生命周期，当对象的生命周期结束时，分配给该对象的内存地址将会被回收。" class="headerlink" title="每个对象都有生命周期，当对象的生命周期结束时，分配给该对象的内存地址将会被回收。"></a>每个对象都有生命周期，当对象的生命周期结束时，分配给该对象的内存地址将会被回收。</h5><h5 id="其他语言需要手动回收废弃的对象，但是Java拥有一套完整的垃圾回收机制，用户不必担心对象占用内存，垃圾回收器将回收无用的但占用内存的资源"><a href="#其他语言需要手动回收废弃的对象，但是Java拥有一套完整的垃圾回收机制，用户不必担心对象占用内存，垃圾回收器将回收无用的但占用内存的资源" class="headerlink" title="其他语言需要手动回收废弃的对象，但是Java拥有一套完整的垃圾回收机制，用户不必担心对象占用内存，垃圾回收器将回收无用的但占用内存的资源"></a>其他语言需要手动回收废弃的对象，但是Java拥有一套完整的垃圾回收机制，用户不必担心对象占用内存，垃圾回收器将回收无用的但占用内存的资源</h5><h4 id="垃圾"><a href="#垃圾" class="headerlink" title="垃圾"></a>垃圾</h4><h5 id="对象引用超过其作用范围，这个对象将被视为垃圾"><a href="#对象引用超过其作用范围，这个对象将被视为垃圾" class="headerlink" title="对象引用超过其作用范围，这个对象将被视为垃圾"></a>对象引用超过其作用范围，这个对象将被视为垃圾</h5><h5 id="将对象赋值给null"><a href="#将对象赋值给null" class="headerlink" title="将对象赋值给null"></a>将对象赋值给null</h5><h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><h5 id="很完善"><a href="#很完善" class="headerlink" title="很完善"></a>很完善</h5><h5 id="但是只能回收那些由new操作符创建的对象，"><a href="#但是只能回收那些由new操作符创建的对象，" class="headerlink" title="但是只能回收那些由new操作符创建的对象，"></a>但是只能回收那些由new操作符创建的对象，</h5><h5 id="如果某些对象不能通过new操作符在内存中获取一块内存区域，这种对象可能不能被垃圾回收机制所识别，所以在java中提供了一个finalize-方法"><a href="#如果某些对象不能通过new操作符在内存中获取一块内存区域，这种对象可能不能被垃圾回收机制所识别，所以在java中提供了一个finalize-方法" class="headerlink" title="如果某些对象不能通过new操作符在内存中获取一块内存区域，这种对象可能不能被垃圾回收机制所识别，所以在java中提供了一个finalize()方法"></a>如果某些对象不能通过new操作符在内存中获取一块内存区域，这种对象可能不能被垃圾回收机制所识别，所以在java中提供了一个finalize()方法</h5><h4 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h4><h5 id="是Object类的方法，被声明为protected，用户可以在自己的类中定义这个方法"><a href="#是Object类的方法，被声明为protected，用户可以在自己的类中定义这个方法" class="headerlink" title="是Object类的方法，被声明为protected，用户可以在自己的类中定义这个方法"></a>是Object类的方法，被声明为protected，用户可以在自己的类中定义这个方法</h5><h5 id="如果用户在类中定义了finalized方法，在垃圾回收时会首先调用该方法，在下一次垃圾回收动作发生时，才能真正回收被对象占用的内存。"><a href="#如果用户在类中定义了finalized方法，在垃圾回收时会首先调用该方法，在下一次垃圾回收动作发生时，才能真正回收被对象占用的内存。" class="headerlink" title="如果用户在类中定义了finalized方法，在垃圾回收时会首先调用该方法，在下一次垃圾回收动作发生时，才能真正回收被对象占用的内存。"></a>如果用户在类中定义了finalized方法，在垃圾回收时会首先调用该方法，在下一次垃圾回收动作发生时，才能真正回收被对象占用的内存。</h5><h4 id="有一点需要明确的是，垃圾回收或finalized方法不保证一定会发生，如Java虚拟机内存损耗待尽时，它是不会执行垃圾回收的。"><a href="#有一点需要明确的是，垃圾回收或finalized方法不保证一定会发生，如Java虚拟机内存损耗待尽时，它是不会执行垃圾回收的。" class="headerlink" title="有一点需要明确的是，垃圾回收或finalized方法不保证一定会发生，如Java虚拟机内存损耗待尽时，它是不会执行垃圾回收的。"></a>有一点需要明确的是，垃圾回收或finalized方法不保证一定会发生，如Java虚拟机内存损耗待尽时，它是不会执行垃圾回收的。</h4><h4 id="由于垃圾回收不受人为控制，具体执行时间也不确定，所以finalized方法也就无法执行，"><a href="#由于垃圾回收不受人为控制，具体执行时间也不确定，所以finalized方法也就无法执行，" class="headerlink" title="由于垃圾回收不受人为控制，具体执行时间也不确定，所以finalized方法也就无法执行，"></a>由于垃圾回收不受人为控制，具体执行时间也不确定，所以finalized方法也就无法执行，</h4><h5 id="为此，Java提供了System-gc-方法强制启动垃圾回收器。"><a href="#为此，Java提供了System-gc-方法强制启动垃圾回收器。" class="headerlink" title="为此，Java提供了System.gc()方法强制启动垃圾回收器。"></a>为此，Java提供了System.gc()方法强制启动垃圾回收器。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试编写一个类,定义一个修饰权限为private的成员变量,并定义两个成员方法,一个成语方法实现为此成员变量赋值,另一个成员方法获取这个成员变量的值,保证其他类继承该类时能获取该类的成员变量的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exercise</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">exercise</span><span class="params">(<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = tp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        exercise exer = <span class="keyword">new</span> exercise(<span class="number">10</span>);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试编写一个矩形类,将长与款作为矩形类的属性,在构造方法中将长.宽初始化,定义一个成员方法求此矩形的面积</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rect</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">rect</span><span class="params">(<span class="keyword">double</span> le,<span class="keyword">double</span> wi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = le;</span><br><span class="line">        <span class="keyword">this</span>.width = wi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.length)*(<span class="keyword">this</span>.width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        rect re = <span class="keyword">new</span> rect(<span class="number">2.3</span>,<span class="number">2.3</span>);</span><br><span class="line">        System.out.println(re.area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据运行参数的个数决定循环打印变量i值的次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">        System.out.println(i);p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/13/java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java数组</title>
      <link>http://example.com/2021/06/12/Java%E6%95%B0%E7%BB%84/</link>
      <guid>http://example.com/2021/06/12/Java%E6%95%B0%E7%BB%84/</guid>
      <pubDate>Sat, 12 Jun 2021 13:16:48 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><span id="more"></span><h2 id="一维数组的创建并使用"><a href="#一维数组的创建并使用" class="headerlink" title="一维数组的创建并使用"></a>一维数组的创建并使用</h2><h3 id="一维数组实质上是一组相同数据类型的线性集合-当在程序中需要处理一组数据-或者传递一组数据时-可以应用这种类型的数组"><a href="#一维数组实质上是一组相同数据类型的线性集合-当在程序中需要处理一组数据-或者传递一组数据时-可以应用这种类型的数组" class="headerlink" title="一维数组实质上是一组相同数据类型的线性集合,当在程序中需要处理一组数据,或者传递一组数据时,可以应用这种类型的数组."></a>一维数组实质上是一组相同数据类型的线性集合,当在程序中需要处理一组数据,或者传递一组数据时,可以应用这种类型的数组.</h3><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h3><h4 id="数组作为对象允许使用new关键字进行内存分配"><a href="#数组作为对象允许使用new关键字进行内存分配" class="headerlink" title="数组作为对象允许使用new关键字进行内存分配."></a>数组作为对象允许使用new关键字进行内存分配.</h4><h4 id="使用数组之前-必须首先定义数组变量所属的类型"><a href="#使用数组之前-必须首先定义数组变量所属的类型" class="headerlink" title="使用数组之前,必须首先定义数组变量所属的类型."></a>使用数组之前,必须首先定义数组变量所属的类型.</h4><h4 id="一维数组的创建"><a href="#一维数组的创建" class="headerlink" title="一维数组的创建"></a>一维数组的创建</h4><h5 id="类型-数组名-类型-数组名"><a href="#类型-数组名-类型-数组名" class="headerlink" title="类型 数组名[]; 类型[] 数组名;"></a>类型 数组名[]; 类型[] 数组名;</h5><h5 id="数组名字-new-数组元素的类型-数组元素的个数"><a href="#数组名字-new-数组元素的类型-数组元素的个数" class="headerlink" title="数组名字 = new 数组元素的类型[数组元素的个数]"></a>数组名字 = new 数组元素的类型[数组元素的个数]</h5><h5 id="使用new关键字为数组分配内存时，整型数组中各个元素的初始值都为0"><a href="#使用new关键字为数组分配内存时，整型数组中各个元素的初始值都为0" class="headerlink" title="使用new关键字为数组分配内存时，整型数组中各个元素的初始值都为0"></a>使用new关键字为数组分配内存时，整型数组中各个元素的初始值都为0</h5><h5 id="数组元素的类型-数组名-new-数组元素的类型-数组元素的个数"><a href="#数组元素的类型-数组名-new-数组元素的类型-数组元素的个数" class="headerlink" title="数组元素的类型 数组名 = new 数组元素的类型[数组元素的个数];"></a>数组元素的类型 数组名 = new 数组元素的类型[数组元素的个数];</h5><h6 id="这种i创建数组的方法是将数组的声明和内存的分配合在一起执行"><a href="#这种i创建数组的方法是将数组的声明和内存的分配合在一起执行" class="headerlink" title="这种i创建数组的方法是将数组的声明和内存的分配合在一起执行"></a>这种i创建数组的方法是将数组的声明和内存的分配合在一起执行</h6><h3 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h3><h4 id="int-arr-new-int-1-2-3-4-5"><a href="#int-arr-new-int-1-2-3-4-5" class="headerlink" title="int arr[] = new int[1,2,3,4,5];"></a><code>int arr[] = new int[1,2,3,4,5];</code></h4><h4 id="int-arr-1-2-3-4-5"><a href="#int-arr-1-2-3-4-5" class="headerlink" title="int arr[] = {1,2,3,4,5};"></a><code>int arr[] = &#123;1,2,3,4,5&#125;;</code></h4><h3 id="二维数组的创建及使用"><a href="#二维数组的创建及使用" class="headerlink" title="二维数组的创建及使用"></a>二维数组的创建及使用</h3><h4 id="如果一维数组中的各个元素仍然是一个数组-那么它就是一个二维数组-二维数组常用于表示表-表中的信息以行和列的形式组织-第一个下标时行-第二个是列"><a href="#如果一维数组中的各个元素仍然是一个数组-那么它就是一个二维数组-二维数组常用于表示表-表中的信息以行和列的形式组织-第一个下标时行-第二个是列" class="headerlink" title="如果一维数组中的各个元素仍然是一个数组,那么它就是一个二维数组.二维数组常用于表示表,表中的信息以行和列的形式组织,第一个下标时行,第二个是列"></a>如果一维数组中的各个元素仍然是一个数组,那么它就是一个二维数组.二维数组常用于表示表,表中的信息以行和列的形式组织,第一个下标时行,第二个是列</h4><h4 id="二维数组的创建"><a href="#二维数组的创建" class="headerlink" title="二维数组的创建"></a>二维数组的创建</h4><h5 id="基本与一维数组创建方式差不多"><a href="#基本与一维数组创建方式差不多" class="headerlink" title="基本与一维数组创建方式差不多"></a>基本与一维数组创建方式差不多</h5><h5 id="声明的同时为数组分配内存"><a href="#声明的同时为数组分配内存" class="headerlink" title="声明的同时为数组分配内存"></a>声明的同时为数组分配内存</h5><h5 id="使用这种方式为数组分配内存时-首先指定最左边维数的内存-然后单独地给余下的维数分配内存"><a href="#使用这种方式为数组分配内存时-首先指定最左边维数的内存-然后单独地给余下的维数分配内存" class="headerlink" title="使用这种方式为数组分配内存时,首先指定最左边维数的内存,然后单独地给余下的维数分配内存."></a>使用这种方式为数组分配内存时,首先指定最左边维数的内存,然后单独地给余下的维数分配内存.</h5><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><h4 id="基本与一维数组相同"><a href="#基本与一维数组相同" class="headerlink" title="基本与一维数组相同"></a>基本与一维数组相同</h4><h4 id="对于整型二维数组-创建成功之后系统会赋给数组中每个元素初始值为0"><a href="#对于整型二维数组-创建成功之后系统会赋给数组中每个元素初始值为0" class="headerlink" title="对于整型二维数组,创建成功之后系统会赋给数组中每个元素初始值为0"></a>对于整型二维数组,创建成功之后系统会赋给数组中每个元素初始值为0</h4><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><h3 id="java-util包的Arrays类包含了用来操作数组-如排序和搜索-的各种方法"><a href="#java-util包的Arrays类包含了用来操作数组-如排序和搜索-的各种方法" class="headerlink" title="java.util包的Arrays类包含了用来操作数组(如排序和搜索)的各种方法."></a>java.util包的Arrays类包含了用来操作数组(如排序和搜索)的各种方法.</h3><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><h4 id="遍历数组就是获取数组中每个元素-通常遍历数组都是使用for循环来实现"><a href="#遍历数组就是获取数组中每个元素-通常遍历数组都是使用for循环来实现" class="headerlink" title="遍历数组就是获取数组中每个元素.通常遍历数组都是使用for循环来实现."></a>遍历数组就是获取数组中每个元素.通常遍历数组都是使用for循环来实现.</h4><h4 id="遍历二维数组需要用到双层for循环-通过数组的length属性可获得数组的长度"><a href="#遍历二维数组需要用到双层for循环-通过数组的length属性可获得数组的长度" class="headerlink" title="遍历二维数组需要用到双层for循环,通过数组的length属性可获得数组的长度"></a>遍历二维数组需要用到双层for循环,通过数组的length属性可获得数组的长度</h4><h4 id="遍历数组时使用foreach语句可能会更简单"><a href="#遍历数组时使用foreach语句可能会更简单" class="headerlink" title="遍历数组时使用foreach语句可能会更简单"></a>遍历数组时使用foreach语句可能会更简单</h4><h3 id="填充替换数组元素"><a href="#填充替换数组元素" class="headerlink" title="填充替换数组元素"></a>填充替换数组元素</h3><h4 id="数组中的元素定义完成后-可以通过Arrays类的静态方法fill-来对数组中的元素进行替换"><a href="#数组中的元素定义完成后-可以通过Arrays类的静态方法fill-来对数组中的元素进行替换" class="headerlink" title="数组中的元素定义完成后,可以通过Arrays类的静态方法fill()来对数组中的元素进行替换."></a>数组中的元素定义完成后,可以通过Arrays类的静态方法fill()来对数组中的元素进行替换.</h4><h4 id="该方法通过各种重载形式可完成对任意类型的数组元素的替换"><a href="#该方法通过各种重载形式可完成对任意类型的数组元素的替换" class="headerlink" title="该方法通过各种重载形式可完成对任意类型的数组元素的替换"></a>该方法通过各种重载形式可完成对任意类型的数组元素的替换</h4><h4 id="fill-int-a-int-value"><a href="#fill-int-a-int-value" class="headerlink" title="fill(int[] a,int value);"></a><code>fill(int[] a,int value);</code></h4><h5 id="该方法可将指定的int值分配给int型数组的每个元素"><a href="#该方法可将指定的int值分配给int型数组的每个元素" class="headerlink" title="该方法可将指定的int值分配给int型数组的每个元素"></a>该方法可将指定的int值分配给int型数组的每个元素</h5><h4 id="fill-int-a-int-fromIndex-int-toIndex-int-value"><a href="#fill-int-a-int-fromIndex-int-toIndex-int-value" class="headerlink" title="fill(int[] a,int fromIndex,int toIndex,int value);"></a><code>fill(int[] a,int fromIndex,int toIndex,int value);</code></h4><h5 id="a-要填充的数组"><a href="#a-要填充的数组" class="headerlink" title="a:要填充的数组"></a>a:要填充的数组</h5><h5 id="fromIndex-要使用指定值填充的第一个元素的索引-包括"><a href="#fromIndex-要使用指定值填充的第一个元素的索引-包括" class="headerlink" title="fromIndex:要使用指定值填充的第一个元素的索引(包括)"></a>fromIndex:要使用指定值填充的第一个元素的索引(包括)</h5><h5 id="toIndex-要使用指定值填充的最后一个元素的索引-不包括"><a href="#toIndex-要使用指定值填充的最后一个元素的索引-不包括" class="headerlink" title="toIndex:要使用指定值填充的最后一个元素的索引(不包括)"></a>toIndex:要使用指定值填充的最后一个元素的索引(不包括)</h5><h5 id="value-要储存的所有的元素的值"><a href="#value-要储存的所有的元素的值" class="headerlink" title="value:要储存的所有的元素的值"></a>value:要储存的所有的元素的值</h5><h5 id="该方法将指定的int值分配给int型数组指定范围中的每个元素。填充的范围从索引fromIndex-包括）一直到索引toIndex（不包括）。如果fromIndex-toIndex-则填充范围为空"><a href="#该方法将指定的int值分配给int型数组指定范围中的每个元素。填充的范围从索引fromIndex-包括）一直到索引toIndex（不包括）。如果fromIndex-toIndex-则填充范围为空" class="headerlink" title="该方法将指定的int值分配给int型数组指定范围中的每个元素。填充的范围从索引fromIndex(包括）一直到索引toIndex（不包括）。如果fromIndex==toIndex,则填充范围为空"></a>该方法将指定的int值分配给int型数组指定范围中的每个元素。填充的范围从索引fromIndex(包括）一直到索引toIndex（不包括）。如果fromIndex==toIndex,则填充范围为空</h5><h5 id="如果指定的索引位置大于或等于要进行填充的数组的长度，则会报出ArrayIndexOutOf-BoundsException-数组越界异常）异常。"><a href="#如果指定的索引位置大于或等于要进行填充的数组的长度，则会报出ArrayIndexOutOf-BoundsException-数组越界异常）异常。" class="headerlink" title="如果指定的索引位置大于或等于要进行填充的数组的长度，则会报出ArrayIndexOutOf,BoundsException(数组越界异常）异常。"></a>如果指定的索引位置大于或等于要进行填充的数组的长度，则会报出ArrayIndexOutOf,BoundsException(数组越界异常）异常。</h5><h3 id="对数组进行排序"><a href="#对数组进行排序" class="headerlink" title="对数组进行排序"></a>对数组进行排序</h3><h4 id="通过Arrays类的静态方法sort-方法可以实现对数组的排序"><a href="#通过Arrays类的静态方法sort-方法可以实现对数组的排序" class="headerlink" title="通过Arrays类的静态方法sort()方法可以实现对数组的排序."></a>通过Arrays类的静态方法sort()方法可以实现对数组的排序.</h4><h4 id="sort-方法提供了多种重载形式-可对任意类型的数组进行升序排序"><a href="#sort-方法提供了多种重载形式-可对任意类型的数组进行升序排序" class="headerlink" title="sort()方法提供了多种重载形式,可对任意类型的数组进行升序排序"></a>sort()方法提供了多种重载形式,可对任意类型的数组进行升序排序</h4><h5 id="Java中的String类型数组的排序算法是根据字典编排顺序排序的-因此数字排在字母的前面-大写字母排在小写字母的前面"><a href="#Java中的String类型数组的排序算法是根据字典编排顺序排序的-因此数字排在字母的前面-大写字母排在小写字母的前面" class="headerlink" title="Java中的String类型数组的排序算法是根据字典编排顺序排序的,因此数字排在字母的前面,大写字母排在小写字母的前面."></a>Java中的String类型数组的排序算法是根据字典编排顺序排序的,因此数字排在字母的前面,大写字母排在小写字母的前面.</h5><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><h4 id="Arrays类的copyOf-方法与copyOfRange-方法可以实现对数组的复制"><a href="#Arrays类的copyOf-方法与copyOfRange-方法可以实现对数组的复制" class="headerlink" title="Arrays类的copyOf()方法与copyOfRange()方法可以实现对数组的复制."></a>Arrays类的copyOf()方法与copyOfRange()方法可以实现对数组的复制.</h4><h4 id="copyOf-方法"><a href="#copyOf-方法" class="headerlink" title="copyOf()方法"></a>copyOf()方法</h4><h5 id="复制数组至指定长度"><a href="#复制数组至指定长度" class="headerlink" title="复制数组至指定长度."></a>复制数组至指定长度.</h5><h5 id="提供了多种重载形式-用于满足不同类型数组的复制"><a href="#提供了多种重载形式-用于满足不同类型数组的复制" class="headerlink" title="提供了多种重载形式,用于满足不同类型数组的复制"></a>提供了多种重载形式,用于满足不同类型数组的复制</h5><h4 id="copyOfRange-方法"><a href="#copyOfRange-方法" class="headerlink" title="copyOfRange()方法"></a>copyOfRange()方法</h4><h5 id="将指定数组的指定长度复制到一个新数组中"><a href="#将指定数组的指定长度复制到一个新数组中" class="headerlink" title="将指定数组的指定长度复制到一个新数组中"></a>将指定数组的指定长度复制到一个新数组中</h5><h5 id="同样提供了多种重载形式"><a href="#同样提供了多种重载形式" class="headerlink" title="同样提供了多种重载形式"></a>同样提供了多种重载形式</h5><h5 id="copyOfRange-arr-iint-fromIndex-int-toIndex"><a href="#copyOfRange-arr-iint-fromIndex-int-toIndex" class="headerlink" title="copyOfRange(arr,iint fromIndex,int toIndex)"></a><code>copyOfRange(arr,iint fromIndex,int toIndex)</code></h5><h6 id="arr-要进行复制的数组对象"><a href="#arr-要进行复制的数组对象" class="headerlink" title="arr:要进行复制的数组对象"></a>arr:要进行复制的数组对象</h6><h6 id="formIndex-指定开始复制数组的索引位置-formIndex必须在0至整个数组的长度之间-新数组包括索引是formIndex的元素"><a href="#formIndex-指定开始复制数组的索引位置-formIndex必须在0至整个数组的长度之间-新数组包括索引是formIndex的元素" class="headerlink" title="formIndex:指定开始复制数组的索引位置.formIndex必须在0至整个数组的长度之间.新数组包括索引是formIndex的元素"></a>formIndex:指定开始复制数组的索引位置.formIndex必须在0至整个数组的长度之间.新数组包括索引是formIndex的元素</h6><h6 id="toIndex-要复制范围的最后索引位置-可大于数组arr的长度-新数组不包含索引是toIndex的元素"><a href="#toIndex-要复制范围的最后索引位置-可大于数组arr的长度-新数组不包含索引是toIndex的元素" class="headerlink" title="toIndex:要复制范围的最后索引位置.可大于数组arr的长度.新数组不包含索引是toIndex的元素."></a>toIndex:要复制范围的最后索引位置.可大于数组arr的长度.新数组不包含索引是toIndex的元素.</h6><h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><h4 id="Arrays类的binarySearch-方法"><a href="#Arrays类的binarySearch-方法" class="headerlink" title="Arrays类的binarySearch()方法,"></a>Arrays类的binarySearch()方法,</h4><h4 id="该方法可使用二分搜索法来搜索指定数组，以获得指定对象。该方法返回要搜索元素的索引值。"><a href="#该方法可使用二分搜索法来搜索指定数组，以获得指定对象。该方法返回要搜索元素的索引值。" class="headerlink" title="该方法可使用二分搜索法来搜索指定数组，以获得指定对象。该方法返回要搜索元素的索引值。"></a>该方法可使用二分搜索法来搜索指定数组，以获得指定对象。该方法返回要搜索元素的索引值。</h4><h4 id="提供了多种重载形式-用于满足各种类型数组的查找需要"><a href="#提供了多种重载形式-用于满足各种类型数组的查找需要" class="headerlink" title="提供了多种重载形式,用于满足各种类型数组的查找需要."></a>提供了多种重载形式,用于满足各种类型数组的查找需要.</h4><h4 id="必须在进行此调用之前对数组进行排序（通过sort-方法）。如果没有对数组进行排序，则结果是不确定的，如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。"><a href="#必须在进行此调用之前对数组进行排序（通过sort-方法）。如果没有对数组进行排序，则结果是不确定的，如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。" class="headerlink" title="必须在进行此调用之前对数组进行排序（通过sort()方法）。如果没有对数组进行排序，则结果是不确定的，如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。"></a>必须在进行此调用之前对数组进行排序（通过sort()方法）。如果没有对数组进行排序，则结果是不确定的，如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。</h4><h4 id="有两种参数类型"><a href="#有两种参数类型" class="headerlink" title="有两种参数类型"></a>有两种参数类型</h4><h5 id="binarySearch-Object-Object-key"><a href="#binarySearch-Object-Object-key" class="headerlink" title="binarySearch(Object[].Object key);"></a><code>binarySearch(Object[].Object key);</code></h5><h6 id="如果key包含在数组中-则返回搜索值的索引-否则返回-1或”-“-插入点-插入点是搜索键将要插入数组的那一点-即第一个大于此键的元素索引"><a href="#如果key包含在数组中-则返回搜索值的索引-否则返回-1或”-“-插入点-插入点是搜索键将要插入数组的那一点-即第一个大于此键的元素索引" class="headerlink" title="如果key包含在数组中,则返回搜索值的索引;否则返回-1或”-“(插入点).插入点是搜索键将要插入数组的那一点,即第一个大于此键的元素索引."></a>如果key包含在数组中,则返回搜索值的索引;否则返回-1或”-“(插入点).插入点是搜索键将要插入数组的那一点,即第一个大于此键的元素索引.</h6><h6 id="如果数组中的所有元素都小于指定的键-则为a-length-注意-这保证了当且仅当此键被找到时-返回的值将大于等于零"><a href="#如果数组中的所有元素都小于指定的键-则为a-length-注意-这保证了当且仅当此键被找到时-返回的值将大于等于零" class="headerlink" title="如果数组中的所有元素都小于指定的键,则为a.length(注意,这保证了当且仅当此键被找到时,返回的值将大于等于零)"></a>如果数组中的所有元素都小于指定的键,则为a.length(注意,这保证了当且仅当此键被找到时,返回的值将大于等于零)</h6><h5 id="binarySearch-Object-int-formIndex-int-toIndex-Object-key"><a href="#binarySearch-Object-int-formIndex-int-toIndex-Object-key" class="headerlink" title="binarySearch(Object[],int formIndex,int toIndex,Object key);"></a><code>binarySearch(Object[],int formIndex,int toIndex,Object key);</code></h5><h6 id="该方法在指定的范围内检索某一元素"><a href="#该方法在指定的范围内检索某一元素" class="headerlink" title="该方法在指定的范围内检索某一元素"></a>该方法在指定的范围内检索某一元素</h6><h6 id="如果数组中的所有元素都小于指定的键-则为toIndex-注意-这保证了当且仅当此键被找到时-返回的值将大于等于零"><a href="#如果数组中的所有元素都小于指定的键-则为toIndex-注意-这保证了当且仅当此键被找到时-返回的值将大于等于零" class="headerlink" title="如果数组中的所有元素都小于指定的键,则为toIndex(注意,这保证了当且仅当此键被找到时,返回的值将大于等于零)"></a>如果数组中的所有元素都小于指定的键,则为toIndex(注意,这保证了当且仅当此键被找到时,返回的值将大于等于零)</h6><h6 id="如果指定的范围大于或等于数组的长度-则会爆出ArraysIndexOutOfBoundsExceptiom异常"><a href="#如果指定的范围大于或等于数组的长度-则会爆出ArraysIndexOutOfBoundsExceptiom异常" class="headerlink" title="如果指定的范围大于或等于数组的长度,则会爆出ArraysIndexOutOfBoundsExceptiom异常"></a>如果指定的范围大于或等于数组的长度,则会爆出ArraysIndexOutOfBoundsExceptiom异常</h6><h2 id="数组排序算法"><a href="#数组排序算法" class="headerlink" title="数组排序算法"></a>数组排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="定义-冒泡排序是最常用的数组排序算法之一-它排序数组元素的过程总是将小数往前放-大数往后放"><a href="#定义-冒泡排序是最常用的数组排序算法之一-它排序数组元素的过程总是将小数往前放-大数往后放" class="headerlink" title="定义:冒泡排序是最常用的数组排序算法之一,它排序数组元素的过程总是将小数往前放,大数往后放,"></a>定义:冒泡排序是最常用的数组排序算法之一,它排序数组元素的过程总是将小数往前放,大数往后放,</h4><h4 id="基本思想-冒泡排序的基本思想是对比相邻的元素值-如果满足条件就交换元素值-把较小的元素移动到数组前面-把大的元素移动到数组的后面-也就是交换两个元素的位置-这样较小的元素就像旗袍一样从底部往上升"><a href="#基本思想-冒泡排序的基本思想是对比相邻的元素值-如果满足条件就交换元素值-把较小的元素移动到数组前面-把大的元素移动到数组的后面-也就是交换两个元素的位置-这样较小的元素就像旗袍一样从底部往上升" class="headerlink" title="基本思想:冒泡排序的基本思想是对比相邻的元素值,如果满足条件就交换元素值,把较小的元素移动到数组前面,把大的元素移动到数组的后面(也就是交换两个元素的位置),这样较小的元素就像旗袍一样从底部往上升."></a>基本思想:冒泡排序的基本思想是对比相邻的元素值,如果满足条件就交换元素值,把较小的元素移动到数组前面,把大的元素移动到数组的后面(也就是交换两个元素的位置),这样较小的元素就像旗袍一样从底部往上升.</h4><h5 id="通常使用双层循环实现"><a href="#通常使用双层循环实现" class="headerlink" title="通常使用双层循环实现"></a>通常使用双层循环实现</h5><h6 id="外层循环-用于控制排序轮数-一般为要排序的数组长度减1次-因为最后只剩下一个数组元素-不需要对比-同时数组已经完成排序了"><a href="#外层循环-用于控制排序轮数-一般为要排序的数组长度减1次-因为最后只剩下一个数组元素-不需要对比-同时数组已经完成排序了" class="headerlink" title="外层循环:用于控制排序轮数,一般为要排序的数组长度减1次,因为最后只剩下一个数组元素,不需要对比,同时数组已经完成排序了."></a>外层循环:用于控制排序轮数,一般为要排序的数组长度减1次,因为最后只剩下一个数组元素,不需要对比,同时数组已经完成排序了.</h6><h6 id="内层循环-用于对比数组中每个临近元素的大小-以确定是否交换位置-对比和交换次数随排序的轮数而减少"><a href="#内层循环-用于对比数组中每个临近元素的大小-以确定是否交换位置-对比和交换次数随排序的轮数而减少" class="headerlink" title="内层循环:用于对比数组中每个临近元素的大小,以确定是否交换位置,对比和交换次数随排序的轮数而减少."></a>内层循环:用于对比数组中每个临近元素的大小,以确定是否交换位置,对比和交换次数随排序的轮数而减少.</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个数组,这个数组元素是乱序的</span></span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">63</span>,<span class="number">65</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">55</span>,<span class="number">100</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//创建冒泡排序类的对象</span></span><br><span class="line">BubbleSort sorter = <span class="keyword">new</span> BubbleSort();</span><br><span class="line"><span class="comment">//调用排序方法将数组排序</span></span><br><span class="line">sorter.sort(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; array.length;i++)&#123;</span><br><span class="line"><span class="comment">//比较相邻两个元素,较大的数往后冒泡</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; array.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> temp = array[j];<span class="comment">//把第一个元素值保存到临时变量中</span></span><br><span class="line">array[j] = array[j + <span class="number">1</span>];<span class="comment">//把第二个元素值保存到第一个元素单元中</span></span><br><span class="line">array[j + <span class="number">1</span>] = temp;<span class="comment">//把临时变量(也就是第一个元素原值)保存到第二个元素中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">showArray(array);<span class="comment">//输出冒泡排序后的数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : array)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">System.out.print(<span class="string">&quot;&gt;&quot;</span> + <span class="number">1</span>);<span class="comment">//输出每个数组元素值</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><h4 id="定义-属于选择排序的一种-它的排序速度要比冒泡快一些-因为交换次数少-也是常用的排序算法"><a href="#定义-属于选择排序的一种-它的排序速度要比冒泡快一些-因为交换次数少-也是常用的排序算法" class="headerlink" title="定义:属于选择排序的一种,它的排序速度要比冒泡快一些,,因为交换次数少,也是常用的排序算法"></a>定义:属于选择排序的一种,它的排序速度要比冒泡快一些,,因为交换次数少,也是常用的排序算法</h4><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><h5 id="将指定排序位置与其他数组元素分别进行对比-如果满足条件就交换元素值-注意这里区别冒泡排序-不是交换相邻元素-而是把满足条件的元素与指定的排序位置交换-如从最后一个元素开始排序"><a href="#将指定排序位置与其他数组元素分别进行对比-如果满足条件就交换元素值-注意这里区别冒泡排序-不是交换相邻元素-而是把满足条件的元素与指定的排序位置交换-如从最后一个元素开始排序" class="headerlink" title="将指定排序位置与其他数组元素分别进行对比,如果满足条件就交换元素值,注意这里区别冒泡排序,不是交换相邻元素,而是把满足条件的元素与指定的排序位置交换(如从最后一个元素开始排序)."></a>将指定排序位置与其他数组元素分别进行对比,如果满足条件就交换元素值,注意这里区别冒泡排序,不是交换相邻元素,而是把满足条件的元素与指定的排序位置交换(如从最后一个元素开始排序).</h5><h5 id="每一趟从待排序的数据元素中选出最大或最小-顺序地放在已排好序的数列的最后-直到全部待排序的数据元素排完"><a href="#每一趟从待排序的数据元素中选出最大或最小-顺序地放在已排好序的数列的最后-直到全部待排序的数据元素排完" class="headerlink" title="每一趟从待排序的数据元素中选出最大或最小,顺序地放在已排好序的数列的最后,直到全部待排序的数据元素排完."></a>每一趟从待排序的数据元素中选出最大或最小,顺序地放在已排好序的数列的最后,直到全部待排序的数据元素排完.</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个数组,这个数组的元素是乱序的</span></span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//创建直接排序类的对象</span></span><br><span class="line">SelectSort sorter = <span class="keyword">new</span> SelectSort&#123;&#125;;</span><br><span class="line"><span class="comment">//调用排序对象的方法将数组排序</span></span><br><span class="line">sorter.sort(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= array.length - i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[j] &gt; array[index])&#123;</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换在位置Array.length - i和index(最大值)上的两个数</span></span><br><span class="line"><span class="keyword">int</span> temp = array[array.length - i];<span class="comment">//把第一个元素值保存到临时变量中</span></span><br><span class="line">array[array.length - i] = array[index];<span class="comment">//把第二个元素值保存到第一个元素单位中</span></span><br><span class="line">array[index] = temp;<span class="comment">//把临时变量也就是第一个元素原值保存到第二个元素中</span></span><br><span class="line">&#125;</span><br><span class="line">showArray(array);<span class="comment">//输出直接选择排序后的数组值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : array)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">System.out.print(<span class="string">&quot;&gt;&quot;</span> + i);<span class="comment">//输出每个数组元素值</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转排序"><a href="#反转排序" class="headerlink" title="反转排序"></a>反转排序</h3><h4 id="定义-以相反的顺序将原有数组的内容重新排序"><a href="#定义-以相反的顺序将原有数组的内容重新排序" class="headerlink" title="定义:以相反的顺序将原有数组的内容重新排序"></a>定义:以相反的顺序将原有数组的内容重新排序</h4><h4 id="基本思想-反转排序的基本思想比较简单-也很好理解-其实现思路就是把数组的最后一个元素与都一个元素进行替换-所以只需要循环数组长度的半数次就可以"><a href="#基本思想-反转排序的基本思想比较简单-也很好理解-其实现思路就是把数组的最后一个元素与都一个元素进行替换-所以只需要循环数组长度的半数次就可以" class="headerlink" title="基本思想:反转排序的基本思想比较简单,也很好理解,其实现思路就是把数组的最后一个元素与都一个元素进行替换,所以只需要循环数组长度的半数次就可以."></a>基本思想:反转排序的基本思想比较简单,也很好理解,其实现思路就是把数组的最后一个元素与都一个元素进行替换,所以只需要循环数组长度的半数次就可以.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseSort</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">13</span>,<span class="number">26</span>,<span class="number">77</span>,<span class="number">39</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//创建反转排序类的对象</span></span><br><span class="line">ReverseSort sorter = <span class="keyword">new</span> ReverseSort();</span><br><span class="line"><span class="comment">//调用排序对象的方法将数组反转</span></span><br><span class="line">sorter.sort(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;数组原有内容: &quot;</span>);</span><br><span class="line">showArray(array);<span class="comment">//输出排序前的数组值</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> len = array.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">temp = array[i];</span><br><span class="line">array[i] = array[len - <span class="number">1</span> -i];</span><br><span class="line">array[len - <span class="number">1</span> - i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组反转后内容:&quot;</span>);</span><br><span class="line">showArray(array);<span class="comment">//输出排序后的数组值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : array)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span> + i);<span class="comment">//输出每个数组元素值</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/12/Java%E6%95%B0%E7%BB%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSS</title>
      <link>http://example.com/2021/06/12/CSS/</link>
      <guid>http://example.com/2021/06/12/CSS/</guid>
      <pubDate>Sat, 12 Jun 2021 08:13:46 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><span id="more"></span><h2 id="层叠样式表"><a href="#层叠样式表" class="headerlink" title="层叠样式表"></a>层叠样式表</h2><h2 id="CSS用来设置网页中元素的样式"><a href="#CSS用来设置网页中元素的样式" class="headerlink" title="CSS用来设置网页中元素的样式"></a>CSS用来设置网页中元素的样式</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="第一种-在标签内部通过使用style属性来设置元素的样式-lt-p-style-quot-color-red-font-size-60px-quot-gt-zombie-lt-p-gt"><a href="#第一种-在标签内部通过使用style属性来设置元素的样式-lt-p-style-quot-color-red-font-size-60px-quot-gt-zombie-lt-p-gt" class="headerlink" title="第一种:在标签内部通过使用style属性来设置元素的样式 &lt;p style = &quot;color: red; font-size: 60px&quot;&gt;zombie&lt;/p&gt;"></a>第一种:在标签内部通过使用style属性来设置元素的样式 <code>&lt;p style = &quot;color: red; font-size: 60px&quot;&gt;zombie&lt;/p&gt;</code></h3><h3 id="内联样式-行内样式-不推荐使用"><a href="#内联样式-行内样式-不推荐使用" class="headerlink" title="(内联样式,行内样式)不推荐使用"></a>(内联样式,行内样式)不推荐使用</h3><h3 id="第二种-在head里写style标签-得写CSS选择器"><a href="#第二种-在head里写style标签-得写CSS选择器" class="headerlink" title="第二种,在head里写style标签,得写CSS选择器"></a>第二种,在head里写style标签,得写CSS选择器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="selector-tag">p</span>&#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">      <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="css"><span class="xml">      <span class="attribute">font-size</span>: <span class="number">50px</span></span></span></span><br><span class="line"><span class="css"><span class="xml">    &#125;<span class="comment">/*只能对一个网页起作用*/</span></span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="comment">/*</span></span></span></span><br><span class="line"><span class="comment"><span class="css"><span class="xml">    这也是css内部注释</span></span></span></span><br><span class="line"><span class="comment"><span class="css"><span class="xml">    */</span></span></span></span><br><span class="line"><span class="css"><span class="xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><h3 id="第三种-写在外部样式表-就是将CSS样式编写到一个外部得CSS文件中-然后通过link标签来引入外部得CSS文件"><a href="#第三种-写在外部样式表-就是将CSS样式编写到一个外部得CSS文件中-然后通过link标签来引入外部得CSS文件" class="headerlink" title="第三种:写在外部样式表,就是将CSS样式编写到一个外部得CSS文件中,然后通过link标签来引入外部得CSS文件"></a>第三种:写在外部样式表,就是将CSS样式编写到一个外部得CSS文件中,然后通过link标签来引入外部得CSS文件</h3><h3 id="lt-link-rel-quot-stylesheet-quot-href-quot-style-css-quot-gt"><a href="#lt-link-rel-quot-stylesheet-quot-href-quot-style-css-quot-gt" class="headerlink" title="&lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot;&gt;"></a><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot;&gt;</code></h3><h3 id="将样式编写到外部得CSS文件中-可以使用到浏览器得缓存机制-从而加快网页得加载速度-提高用户体验"><a href="#将样式编写到外部得CSS文件中-可以使用到浏览器得缓存机制-从而加快网页得加载速度-提高用户体验" class="headerlink" title="将样式编写到外部得CSS文件中,可以使用到浏览器得缓存机制,从而加快网页得加载速度,提高用户体验"></a>将样式编写到外部得CSS文件中,可以使用到浏览器得缓存机制,从而加快网页得加载速度,提高用户体验</h3><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="通过选择器可以选中页面中的指定元素-比如选p就是选中页面中所有得p元素"><a href="#通过选择器可以选中页面中的指定元素-比如选p就是选中页面中所有得p元素" class="headerlink" title="通过选择器可以选中页面中的指定元素,比如选p就是选中页面中所有得p元素"></a>通过选择器可以选中页面中的指定元素,比如选p就是选中页面中所有得p元素</h3><h2 id="CSS声明块"><a href="#CSS声明块" class="headerlink" title="CSS声明块"></a>CSS声明块</h2><h3 id="通过声明块来指定要为元素设置的样式"><a href="#通过声明块来指定要为元素设置的样式" class="headerlink" title="通过声明块来指定要为元素设置的样式"></a>通过声明块来指定要为元素设置的样式</h3><h3 id="声明块有一个个声明组成"><a href="#声明块有一个个声明组成" class="headerlink" title="声明块有一个个声明组成"></a>声明块有一个个声明组成</h3><h3 id="声明是一个名值对结构-一个样式名对应一个样式值-名和值之间用-样式用-结尾"><a href="#声明是一个名值对结构-一个样式名对应一个样式值-名和值之间用-样式用-结尾" class="headerlink" title="声明是一个名值对结构(一个样式名对应一个样式值),名和值之间用:,样式用;结尾"></a>声明是一个名值对结构(一个样式名对应一个样式值),名和值之间用:,样式用;结尾</h3><hr><hr><h1 id="常用选择器"><a href="#常用选择器" class="headerlink" title="常用选择器"></a>常用选择器</h1><h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><h3 id="作用-根据标签名来选中指定的元素"><a href="#作用-根据标签名来选中指定的元素" class="headerlink" title="作用:根据标签名来选中指定的元素"></a>作用:根据标签名来选中指定的元素</h3><h3 id="语法-标签名-例如-p-h1-div"><a href="#语法-标签名-例如-p-h1-div" class="headerlink" title="语法:标签名{},例如:p{};h1{};div{}"></a>语法:标签名{},例如:p{};h1{};div{}</h3><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><h3 id="作用-根据元素的id属性值选中一个元素"><a href="#作用-根据元素的id属性值选中一个元素" class="headerlink" title="作用:根据元素的id属性值选中一个元素,"></a>作用:根据元素的id属性值选中一个元素,</h3><h3 id="语法-id属性值-例如-zombie"><a href="#语法-id属性值-例如-zombie" class="headerlink" title="语法:#id属性值{},例如: #zombie{},"></a>语法:#id属性值{},例如: #zombie{},</h3><h3 id="id可以重复-但是不能应用于实践"><a href="#id可以重复-但是不能应用于实践" class="headerlink" title="id可以重复,但是不能应用于实践"></a>id可以重复,但是不能应用于实践</h3><h2 id="Class选择器"><a href="#Class选择器" class="headerlink" title="Class选择器"></a>Class选择器</h2><h3 id="作用-可以通过class属性来进行分组-进行一组的选中-它可以重复"><a href="#作用-可以通过class属性来进行分组-进行一组的选中-它可以重复" class="headerlink" title="作用:可以通过class属性来进行分组,进行一组的选中,它可以重复"></a>作用:可以通过class属性来进行分组,进行一组的选中,它可以重复</h3><h3 id="语法-class名称"><a href="#语法-class名称" class="headerlink" title="语法: .class名称{}"></a>语法: .class名称{}</h3><h3 id="也可以设置多个class-使用空格隔开-例如-lt-h1-class-quot-zom-bie-quot-gt-我是属于两个组的哦-lt-h1-gt"><a href="#也可以设置多个class-使用空格隔开-例如-lt-h1-class-quot-zom-bie-quot-gt-我是属于两个组的哦-lt-h1-gt" class="headerlink" title="也可以设置多个class,使用空格隔开,例如&lt;h1 class=&quot;zom bie&quot;&gt;我是属于两个组的哦&lt;/h1&gt;"></a>也可以设置多个class,使用空格隔开,例如<code>&lt;h1 class=&quot;zom bie&quot;&gt;我是属于两个组的哦&lt;/h1&gt;</code></h3><h2 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h2><h3 id="作用-选中页面中的所有元素"><a href="#作用-选中页面中的所有元素" class="headerlink" title="作用:选中页面中的所有元素"></a>作用:选中页面中的所有元素</h3><h3 id="语法"><a href="#语法" class="headerlink" title="语法: *"></a>语法: *</h3><hr><hr><h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div.red&#123;&#125;<span class="comment">/*元素选择器+class选择器&#123;&#125;  因为必须使用元素选择器开头*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">交集选择器</span></span><br><span class="line"><span class="comment">作用:选中同时复合多个条件的元素</span></span><br><span class="line"><span class="comment">语法:选择器1选择器2选择器3....&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">h1,span&#123;&#125;<span class="comment">/*不是单独只能使用元素选择器,所有的都可以组合*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选择器分组(并集选择器)</span></span><br><span class="line"><span class="comment">作用:同时选择多个选择器对应的元素</span></span><br><span class="line"><span class="comment">语法:选择器1,选择器2,选择器3....&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">我是div</span><br><span class="line">&lt;p&gt;</span><br><span class="line">我是div中的p元素(父子关系)</span><br><span class="line">&lt;span&gt;我是p中的span元素(父子关系),我(后代)是div(祖先)的后代元素&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是div中的span元素(父子关系),我与p是兄弟关系<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div &gt; span&#123;&#125;<span class="comment">/* div.class名 &gt; span&#123;&#125;可以混合使用的*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">子元素选择器</span></span><br><span class="line"><span class="comment">作用:选中指定父元素的指定子元素</span></span><br><span class="line"><span class="comment">语法:父元素 &gt; 子元素&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     div span&#123;&#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     后代元素选择器</span></span><br><span class="line"><span class="comment">     作用:选中指定元素内的指定后代元素</span></span><br><span class="line"><span class="comment">     语法:祖先 后代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     p + span&#123;&#125;<span class="comment">/*紧挨着的才可以,中间隔一个都不行*/</span></span><br><span class="line">     p ~ span&#123;&#125;<span class="comment">/*选中后面所有的兄弟*/</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     兄弟元素选择器</span></span><br><span class="line"><span class="comment">     作用:选择下一个兄弟</span></span><br><span class="line"><span class="comment">     语法:前一个 + 下一个&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><h2 id="因为有class和id的选择器-所以属性一般对其使用"><a href="#因为有class和id的选择器-所以属性一般对其使用" class="headerlink" title="因为有class和id的选择器,所以属性一般对其使用"></a>因为有class和id的选择器,所以属性一般对其使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/* [属性名] 选择含有指定属性的元素 */</span></span><br><span class="line">p[title]&#123;&#125;<span class="comment">/* 选择p标签且含有title属性的元素 */</span></span><br><span class="line"><span class="comment">/* [属性名=属性值] 选择含有指定属性和属性值的元素 */</span></span><br><span class="line">p[title = <span class="string">&quot;zombie&quot;</span>]&#123;&#125;</span><br><span class="line"><span class="comment">/* [属性名^=属性值] 选择属性值以指定值开头的元素 */</span></span><br><span class="line">p[title^=zombie]&#123;&#125;</span><br><span class="line"><span class="comment">/* [属性名$=属性值] 选择属性值以指定值结尾的元素 */</span></span><br><span class="line">p[title$=zombie]&#123;&#125;</span><br><span class="line"><span class="comment">/* [属性名*=属性值] 选择属性值中含有某值的元素 位置不重要有这个值或这个字母即可 */</span></span><br><span class="line">p[title*=zombie]&#123;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/*伪类(不存在的类,特殊的)</span></span><br><span class="line"><span class="comment">伪类用来描述一个元素的特殊状态</span></span><br><span class="line"><span class="comment">比如:第一个子元素,被点击的元素,鼠标移入的元素...</span></span><br><span class="line"><span class="comment">伪类一般情况下都是:开头</span></span><br><span class="line"><span class="comment">:first-child 第一个子元素</span></span><br><span class="line"><span class="comment">:last-child 最后一个子元素</span></span><br><span class="line"><span class="comment">:nth-child(n) 选中第n个子元素 </span></span><br><span class="line"><span class="comment">     特殊值:n 第n个</span></span><br><span class="line"><span class="comment">            2n /even 偶数位</span></span><br><span class="line"><span class="comment">            2n+1 /odd 奇数位</span></span><br><span class="line"><span class="comment"> 以上根据所有子元素进行排位,不是单独某一个</span></span><br><span class="line"><span class="comment"> :first-of-type</span></span><br><span class="line"><span class="comment"> :last-of-type</span></span><br><span class="line"><span class="comment"> :nth-of-type()</span></span><br><span class="line"><span class="comment"> 跟上面相同,不过他们是在同类型中进行排序</span></span><br><span class="line"><span class="comment"> :not() 否定伪类</span></span><br><span class="line"><span class="comment"> 将符合条件的元素从选择器中去除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ul &gt; li:first-child&#123;&#125;</span><br><span class="line">ul &gt; li:<span class="function"><span class="title">not</span>(<span class="params">:first-child</span>)</span>&#123;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="超链接伪类"><a href="#超链接伪类" class="headerlink" title="超链接伪类"></a>超链接伪类</h2><h3 id="超链接访问没访问过是不同的状态-主要区别是颜色不同-一红一蓝"><a href="#超链接访问没访问过是不同的状态-主要区别是颜色不同-一红一蓝" class="headerlink" title="超链接访问没访问过是不同的状态,主要区别是颜色不同,一红一蓝"></a>超链接访问没访问过是不同的状态,主要区别是颜色不同,一红一蓝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">link 用来表示没访问过的连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a:link&#123;</span><br><span class="line"><span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">:visited 用来表示访问过的链接</span></span><br><span class="line"><span class="comment">由于隐私的原因,所以visited这个伪类只能修改链接的颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">a</span>:visited&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">:hover 用来表示鼠标移入的状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">a</span>:hover&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">:active 用来表示鼠标点击</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">a</span>:active&#123;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h1><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><h3 id="表示页面中一些特殊的并不真实的存在的元素怒-特殊的位置"><a href="#表示页面中一些特殊的并不真实的存在的元素怒-特殊的位置" class="headerlink" title="表示页面中一些特殊的并不真实的存在的元素怒(特殊的位置)"></a>表示页面中一些特殊的并不真实的存在的元素怒(特殊的位置)</h3><h3 id="伪元素使用-开头"><a href="#伪元素使用-开头" class="headerlink" title="伪元素使用 :: 开头"></a>伪元素使用 :: 开头</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">::first-letter 表示第一个字母</span></span><br><span class="line"><span class="comment">::first-line 表示第一行</span></span><br><span class="line"><span class="comment">::selection 表示选中的内容</span></span><br><span class="line"><span class="comment">::before 元素的开始位置</span></span><br><span class="line"><span class="comment">::after 元素的最后位置</span></span><br><span class="line"><span class="comment">- before 和 after 必须结合content属性来使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">p::first-letter&#123;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="样式的继承"><a href="#样式的继承" class="headerlink" title="样式的继承"></a>样式的继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*样式的继承:我们为一个元素设置的样式同时也会应用到它的后代身上*/</span></span><br><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承发生在后代和祖先之间,祖先样式会被后代继承</span></span><br><span class="line"><span class="comment">可以设置一次,其他就全设置具有该样式</span></span><br><span class="line"><span class="comment">并不是所有的样式都被继承,背景和布局相关的等不会被继承</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h1><h2 id="样式冲突"><a href="#样式冲突" class="headerlink" title="样式冲突"></a>样式冲突</h2><h3 id="当我们通过不同的选择器-选中相同的元素-并且为相同的样式修改不同的样式"><a href="#当我们通过不同的选择器-选中相同的元素-并且为相同的样式修改不同的样式" class="headerlink" title="当我们通过不同的选择器,选中相同的元素,并且为相同的样式修改不同的样式"></a>当我们通过不同的选择器,选中相同的元素,并且为相同的样式修改不同的样式</h3><h3 id="发生冲突后-谁优先由选择器的权重决定"><a href="#发生冲突后-谁优先由选择器的权重决定" class="headerlink" title="发生冲突后,谁优先由选择器的权重决定"></a>发生冲突后,谁优先由选择器的权重决定</h3><h4 id="选择器的权重-1"><a href="#选择器的权重-1" class="headerlink" title="选择器的权重"></a>选择器的权重</h4><h4 id="内联样式-优先级1000"><a href="#内联样式-优先级1000" class="headerlink" title="内联样式:优先级1000,"></a>内联样式:优先级1000,</h4><h4 id="id选择器-优先级100"><a href="#id选择器-优先级100" class="headerlink" title="id选择器:优先级100,"></a>id选择器:优先级100,</h4><h4 id="类选择器-伪类选择器-优先级10"><a href="#类选择器-伪类选择器-优先级10" class="headerlink" title="类选择器/伪类选择器:优先级10,"></a>类选择器/伪类选择器:优先级10,</h4><h4 id="元素选择器-优先级1"><a href="#元素选择器-优先级1" class="headerlink" title="元素选择器:优先级1,"></a>元素选择器:优先级1,</h4><h4 id="通配选择器-优先级0"><a href="#通配选择器-优先级0" class="headerlink" title="通配选择器:优先级0"></a>通配选择器:优先级0</h4><h4 id="继承的样式-没有优先级"><a href="#继承的样式-没有优先级" class="headerlink" title="继承的样式:没有优先级"></a>继承的样式:没有优先级</h4><h4 id="并集-比较优先级-需要将所有的选择器的优先级加在一起-再对比-选择器累加即使再高也不会超过上一级的选择器-不能跨数量级"><a href="#并集-比较优先级-需要将所有的选择器的优先级加在一起-再对比-选择器累加即使再高也不会超过上一级的选择器-不能跨数量级" class="headerlink" title="并集:比较优先级,需要将所有的选择器的优先级加在一起,再对比,选择器累加即使再高也不会超过上一级的选择器,不能跨数量级"></a>并集:比较优先级,需要将所有的选择器的优先级加在一起,再对比,选择器累加即使再高也不会超过上一级的选择器,不能跨数量级</h4><h4 id="分组选择器单独计算-谁的优先级就是谁的优先级-因为是逗号隔开的"><a href="#分组选择器单独计算-谁的优先级就是谁的优先级-因为是逗号隔开的" class="headerlink" title="分组选择器单独计算,谁的优先级就是谁的优先级,因为是逗号隔开的"></a>分组选择器单独计算,谁的优先级就是谁的优先级,因为是逗号隔开的</h4><h4 id="可以再某一个样式的后边添加-important-则此时该样式或获取到最高的优先级-甚至超过内联样式"><a href="#可以再某一个样式的后边添加-important-则此时该样式或获取到最高的优先级-甚至超过内联样式" class="headerlink" title="可以再某一个样式的后边添加 !important,则此时该样式或获取到最高的优先级,甚至超过内联样式"></a>可以再某一个样式的后边添加 !important,则此时该样式或获取到最高的优先级,甚至超过内联样式</h4><hr><hr><h1 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h1><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><h3 id="由一个个小点构成"><a href="#由一个个小点构成" class="headerlink" title="由一个个小点构成"></a>由一个个小点构成</h3><h3 id="不同屏幕下像素不一样-所以相同的200px不一定一样大"><a href="#不同屏幕下像素不一样-所以相同的200px不一定一样大" class="headerlink" title="不同屏幕下像素不一样,所以相同的200px不一定一样大"></a>不同屏幕下像素不一样,所以相同的200px不一定一样大</h3><h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><h3 id="百分比可以设置属性值相对于父元素属性的百分比-跟随父元素改变"><a href="#百分比可以设置属性值相对于父元素属性的百分比-跟随父元素改变" class="headerlink" title="百分比可以设置属性值相对于父元素属性的百分比,跟随父元素改变"></a>百分比可以设置属性值相对于父元素属性的百分比,跟随父元素改变</h3><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><h3 id="是相对于元素的字体大小来计算的"><a href="#是相对于元素的字体大小来计算的" class="headerlink" title="是相对于元素的字体大小来计算的"></a>是相对于元素的字体大小来计算的</h3><h3 id="1em-1font-size"><a href="#1em-1font-size" class="headerlink" title="1em = 1font-size"></a>1em = 1font-size</h3><h3 id="em会根据字体大小的改变而改变"><a href="#em会根据字体大小的改变而改变" class="headerlink" title="em会根据字体大小的改变而改变"></a>em会根据字体大小的改变而改变</h3><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><h4 id="rem是相对于根元素的字体大小来计算"><a href="#rem是相对于根元素的字体大小来计算" class="headerlink" title="rem是相对于根元素的字体大小来计算"></a>rem是相对于根元素的字体大小来计算</h4><hr><hr><h1 id="颜色单位"><a href="#颜色单位" class="headerlink" title="颜色单位"></a>颜色单位</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.box1&#123;</span><br><span class="line"><span class="attr">width</span>: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">颜色单位</span></span><br><span class="line"><span class="comment">在CSS中可以直接使用颜色名来设置各种颜色</span></span><br><span class="line"><span class="comment">RGB值也可以</span></span><br><span class="line"><span class="comment">RGB通过三种颜色的不同浓度来调配出不同的颜色</span></span><br><span class="line"><span class="comment">R:red G:green B:blue</span></span><br><span class="line"><span class="comment">每一种颜色的范围在0 - 255之间</span></span><br><span class="line"><span class="comment">语法:RGB(红色,绿色,蓝色)</span></span><br><span class="line"><span class="comment">RGBA:</span></span><br><span class="line"><span class="comment">在RGB的基础上增加了一个a表示不透明度</span></span><br><span class="line"><span class="comment">需要四个值,前三个和RGB一样,后一个表示不透明度</span></span><br><span class="line"><span class="comment">1表示完全不透明,0表示完全透明,0.5半透明</span></span><br><span class="line"><span class="comment">十六进制的RGB值</span></span><br><span class="line"><span class="comment">语法:#红色,绿色,蓝色</span></span><br><span class="line"><span class="comment">颜色浓度通过 00-ff</span></span><br><span class="line"><span class="comment">如果颜色两两重复可以进行简写</span></span><br><span class="line"><span class="comment">#aabbcc ---&gt; #abc</span></span><br><span class="line"><span class="comment">HSL值 HSLA值</span></span><br><span class="line"><span class="comment">H:色相 0-360</span></span><br><span class="line"><span class="comment">S:饱和度 颜色的浓度 0 - 100</span></span><br><span class="line"><span class="comment">L:亮度 颜色的亮度 0-100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">          background-color: rgb(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)<span class="comment">//白</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><h2 id="文档流-normal-flow-这些层中最底下的被称为文档流"><a href="#文档流-normal-flow-这些层中最底下的被称为文档流" class="headerlink" title="文档流(normal flow):这些层中最底下的被称为文档流"></a>文档流(normal flow):这些层中最底下的被称为文档流</h2><h2 id="元素有两个状态-在文档流中和不在文档流中-脱离文档流"><a href="#元素有两个状态-在文档流中和不在文档流中-脱离文档流" class="headerlink" title="元素有两个状态:在文档流中和不在文档流中(脱离文档流)"></a>元素有两个状态:在文档流中和不在文档流中(脱离文档流)</h2><hr><hr><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">box model:</span></span><br><span class="line"><span class="comment">-CSS将页面中的所有元素都设置为了一个矩形的盒子</span></span><br><span class="line"><span class="comment">-将元素设置为矩形的盒子后,对页面的布局就变成将不同的盒子摆放到不同的位置</span></span><br><span class="line"><span class="comment">-每一个盒子都由以下几个部分组成</span></span><br><span class="line"><span class="comment">-内容区(content):元素中的所有子元素和文本内容都在内容去中排列</span></span><br><span class="line"><span class="comment">-width:设置内容区的宽度</span></span><br><span class="line"><span class="comment">-height:设置内容区的高度</span></span><br><span class="line"><span class="comment">-内边距(padding):内容区和边框之间的距离</span></span><br><span class="line"><span class="comment">padding-top:</span></span><br><span class="line"><span class="comment">padding-right:</span></span><br><span class="line"><span class="comment">padding-bottom:</span></span><br><span class="line"><span class="comment">padding-left:</span></span><br><span class="line"><span class="comment">-边框(border):属于盒子边缘,</span></span><br><span class="line"><span class="comment">-边框的宽度:border-width:有默认值,三个像素:一共四个值.</span></span><br><span class="line"><span class="comment">有border-xxx-width:top right bottom left,用于单独设置</span></span><br><span class="line"><span class="comment">-边框的颜色border-color</span></span><br><span class="line"><span class="comment">-边框的样式border-style</span></span><br><span class="line"><span class="comment">border简写属性,通过该属性可以同时设置边框所有的相关样式,并且没有顺序要求</span></span><br><span class="line"><span class="comment">-外边距(margin):</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="盒子大小"><a href="#盒子大小" class="headerlink" title="盒子大小"></a>盒子大小</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*bos-sizing:用来设置盒子大小的计算方式(设置width和height的作用)</span></span><br><span class="line"><span class="comment">content-box:默认值,宽度和高度用来设置内容的大小</span></span><br><span class="line"><span class="comment">border-box:宽度和高度用来设置整个盒子可见框的大小*/</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="轮廓和圆角"><a href="#轮廓和圆角" class="headerlink" title="轮廓和圆角"></a>轮廓和圆角</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">outline 用来设置元素的轮廓线,用法和border一摸一样</span></span></span><br><span class="line"><span class="comment"><span class="css">轮廓和边框不同的点,就是轮廓不会影响到可见框的大小</span></span></span><br><span class="line"><span class="comment"><span class="css">*/</span></span></span><br><span class="line"><span class="css"><span class="attribute">outline</span>:<span class="number">10px</span> red solid;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%A0%B7%E5%BC%8F/">样式</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/12/CSS/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java练习题</title>
      <link>http://example.com/2021/06/11/Java%E7%BB%83%E4%B9%A0%E9%A2%98/</link>
      <guid>http://example.com/2021/06/11/Java%E7%BB%83%E4%B9%A0%E9%A2%98/</guid>
      <pubDate>Fri, 11 Jun 2021 13:24:57 GMT</pubDate>
      
      
      
      
      
      
      <comments>http://example.com/2021/06/11/Java%E7%BB%83%E4%B9%A0%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HTML</title>
      <link>http://example.com/2021/06/11/HTML/</link>
      <guid>http://example.com/2021/06/11/HTML/</guid>
      <pubDate>Fri, 11 Jun 2021 06:08:09 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><span id="more"></span><h1 id="网页开发标准W3C"><a href="#网页开发标准W3C" class="headerlink" title="网页开发标准W3C"></a>网页开发标准W3C</h1><h2 id="网页分为三部分"><a href="#网页分为三部分" class="headerlink" title="网页分为三部分"></a>网页分为三部分</h2><h3 id="结构-HTML"><a href="#结构-HTML" class="headerlink" title="结构:HTML"></a>结构:HTML</h3><h3 id="表现-CSS"><a href="#表现-CSS" class="headerlink" title="表现:CSS"></a>表现:CSS</h3><h3 id="行为-JavaScript用于响应用户操作"><a href="#行为-JavaScript用于响应用户操作" class="headerlink" title="行为:JavaScript用于响应用户操作"></a>行为:JavaScript用于响应用户操作</h3><hr><hr><h1 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h1><h2 id="超文本标记语言"><a href="#超文本标记语言" class="headerlink" title="超文本标记语言"></a><strong>超文本标记语言</strong></h2><h2 id="使用标签的形式来标识网页中的不同组成成分"><a href="#使用标签的形式来标识网页中的不同组成成分" class="headerlink" title="使用标签的形式来标识网页中的不同组成成分"></a>使用<strong>标签</strong>的形式来标识网页中的不同组成成分</h2><h2 id="所谓超文本指的就是超链接-使用超链接跳转页面"><a href="#所谓超文本指的就是超链接-使用超链接跳转页面" class="headerlink" title="所谓超文本指的就是超链接,使用超链接跳转页面"></a>所谓超文本指的就是<strong>超链接</strong>,使用超链接跳转页面</h2><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="lt-h1-gt-一级标题-lt-h1-gt"><a href="#lt-h1-gt-一级标题-lt-h1-gt" class="headerlink" title="&lt;h1&gt;一级标题&lt;/h1&gt;"></a><code>&lt;h1&gt;一级标题&lt;/h1&gt;</code></h3><h3 id="lt-p-gt-段落-lt-p-gt"><a href="#lt-p-gt-段落-lt-p-gt" class="headerlink" title="&lt;p&gt;段落&lt;/p&gt;"></a><code>&lt;p&gt;段落&lt;/p&gt;</code></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>网页中源数据,不会出现在网页上</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>需要显示的东西写在这里<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自结束标签-lt-img-gt-lt-input-gt"><a href="#自结束标签-lt-img-gt-lt-input-gt" class="headerlink" title="自结束标签&lt;img&gt;&lt;input&gt;"></a>自结束标签<code>&lt;img&gt;&lt;input&gt;</code></h3><h3 id="属性-红色字体-lt-h1-gt-lt-font-color-quot-red-quot-gt-zombies-lt-font-gt-zheng-lt-h1-gt"><a href="#属性-红色字体-lt-h1-gt-lt-font-color-quot-red-quot-gt-zombies-lt-font-gt-zheng-lt-h1-gt" class="headerlink" title="属性:红色字体 &lt;h1&gt;&lt;font color = &quot;red&quot;&gt;zombies&lt;/font&gt;zheng&lt;/h1&gt;"></a>属性:红色字体 <code>&lt;h1&gt;&lt;font color = &quot;red&quot;&gt;zombies&lt;/font&gt;zheng&lt;/h1&gt;</code></h3><hr><hr><h1 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h1><h2 id="在网页中多个空格会被解析成一个空格"><a href="#在网页中多个空格会被解析成一个空格" class="headerlink" title="在网页中多个空格会被解析成一个空格"></a>在网页中多个空格会被解析成一个空格</h2><h2 id="实体的语法"><a href="#实体的语法" class="headerlink" title="实体的语法"></a>实体的语法</h2><h3 id="amp-实体的名字"><a href="#amp-实体的名字" class="headerlink" title="&amp;实体的名字;"></a>&amp;实体的名字;</h3><h4 id="amp-nbsp-空格"><a href="#amp-nbsp-空格" class="headerlink" title="&amp;nbsp:空格"></a>&amp;nbsp:空格</h4><h4 id="amp-gt-大于号"><a href="#amp-gt-大于号" class="headerlink" title="&amp;gt:大于号"></a>&amp;gt:大于号</h4><h4 id="amp-lt-小于号"><a href="#amp-lt-小于号" class="headerlink" title="&amp;lt:小于号"></a>&amp;lt:小于号</h4><h4 id="amp-copy-版权符号"><a href="#amp-copy-版权符号" class="headerlink" title="&amp;copy:版权符号"></a>&amp;copy:版权符号</h4><h3 id="meta主要用于设置网页中的一些元数据-元数据不给用户看-charset-字符集-name-指定的数据名称-content-指定的数据的内容"><a href="#meta主要用于设置网页中的一些元数据-元数据不给用户看-charset-字符集-name-指定的数据名称-content-指定的数据的内容" class="headerlink" title="meta主要用于设置网页中的一些元数据,元数据不给用户看;charset:字符集;name:指定的数据名称;content:指定的数据的内容;"></a>meta主要用于设置网页中的一些元数据,元数据不给用户看;charset:字符集;name:指定的数据名称;content:指定的数据的内容;</h3><h3 id="keywords表示网站的关键字-可以写多个"><a href="#keywords表示网站的关键字-可以写多个" class="headerlink" title="keywords表示网站的关键字.可以写多个"></a>keywords表示网站的关键字.可以写多个</h3><h3 id="description-用于指定网站的描述"><a href="#description-用于指定网站的描述" class="headerlink" title="description 用于指定网站的描述"></a>description 用于指定网站的描述</h3><h3 id="title标签的内容会作为搜索结果的超链接上的文字显示"><a href="#title标签的内容会作为搜索结果的超链接上的文字显示" class="headerlink" title="title标签的内容会作为搜索结果的超链接上的文字显示"></a>title标签的内容会作为搜索结果的超链接上的文字显示</h3><h4 id="lt-meta-name-quot-keywords-quot-content-quot-zombie-quot-gt"><a href="#lt-meta-name-quot-keywords-quot-content-quot-zombie-quot-gt" class="headerlink" title="&lt;meta name=&quot;keywords&quot; content=&quot;zombie&quot;&gt;"></a><code>&lt;meta name=&quot;keywords&quot; content=&quot;zombie&quot;&gt;</code></h4><h4 id="将网页重定向到另一个网站-lt-meta-http-equiv-quot-refresh-quot-content-quot-www-zhengtianhao-cn-quot-gt"><a href="#将网页重定向到另一个网站-lt-meta-http-equiv-quot-refresh-quot-content-quot-www-zhengtianhao-cn-quot-gt" class="headerlink" title="将网页重定向到另一个网站 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;www.zhengtianhao.cn&quot;&gt;"></a>将网页重定向到另一个网站 <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;www.zhengtianhao.cn&quot;&gt;</code></h4><hr><hr><h2 id="标签标题"><a href="#标签标题" class="headerlink" title="标签标题"></a>标签标题</h2><h3 id="h1-h6-六级标题-h1最重要-仅次于title-只能用一个"><a href="#h1-h6-六级标题-h1最重要-仅次于title-只能用一个" class="headerlink" title="h1-h6 六级标题,h1最重要.仅次于title,只能用一个"></a>h1-h6 六级标题,h1最重要.仅次于title,只能用一个</h3><h3 id="独占一行元素被称为快元素-block-element"><a href="#独占一行元素被称为快元素-block-element" class="headerlink" title="独占一行元素被称为快元素(block element)"></a>独占一行元素被称为快元素(block element)</h3><h3 id="p元素表示页面中的段落-也是一个块元素-一般通过块元素对页面进行布局"><a href="#p元素表示页面中的段落-也是一个块元素-一般通过块元素对页面进行布局" class="headerlink" title="p元素表示页面中的段落,也是一个块元素(一般通过块元素对页面进行布局)"></a>p元素表示页面中的段落,也是一个块元素(一般通过块元素对页面进行布局)</h3><h3 id="hgroup标签用来为标题分组-可以将一组相关的标题同时放入到hgroup-也是块元素"><a href="#hgroup标签用来为标题分组-可以将一组相关的标题同时放入到hgroup-也是块元素" class="headerlink" title="hgroup标签用来为标题分组,可以将一组相关的标题同时放入到hgroup,也是块元素"></a>hgroup标签用来为标题分组,可以将一组相关的标题同时放入到hgroup,也是块元素</h3><h3 id="em标签用于表示语音语调的一个家中-不会独占一行的元素叫行内元素-inline-element"><a href="#em标签用于表示语音语调的一个家中-不会独占一行的元素叫行内元素-inline-element" class="headerlink" title="em标签用于表示语音语调的一个家中(不会独占一行的元素叫行内元素(inline element))"></a>em标签用于表示语音语调的一个家中(不会独占一行的元素叫行内元素(inline element))</h3><h3 id="strong标签表示强调-加粗-行内元素-行内元素主要用来包裹文字"><a href="#strong标签表示强调-加粗-行内元素-行内元素主要用来包裹文字" class="headerlink" title="strong标签表示强调,加粗,行内元素(行内元素主要用来包裹文字)"></a>strong标签表示强调,加粗,行内元素(行内元素主要用来包裹文字)</h3><h3 id="blockquote表示一个长引用-块元素-q表示一个短引用"><a href="#blockquote表示一个长引用-块元素-q表示一个短引用" class="headerlink" title="blockquote表示一个长引用,块元素;q表示一个短引用"></a>blockquote表示一个长引用,块元素;q表示一个短引用</h3><h3 id="一般情况下是块元素中放行内元素"><a href="#一般情况下是块元素中放行内元素" class="headerlink" title="一般情况下是块元素中放行内元素"></a>一般情况下是块元素中放行内元素</h3><h3 id="浏览器在解析网页时-会自动对网页下不符合规范的内容进行修正"><a href="#浏览器在解析网页时-会自动对网页下不符合规范的内容进行修正" class="headerlink" title="浏览器在解析网页时,会自动对网页下不符合规范的内容进行修正"></a>浏览器在解析网页时,会自动对网页下不符合规范的内容进行修正</h3><hr><hr><h1 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h1><h3 id="header标签表示网页的头部"><a href="#header标签表示网页的头部" class="headerlink" title="header标签表示网页的头部"></a>header标签表示网页的头部</h3><h3 id="main标签表示网页的主体部分-一个网页只能有一个"><a href="#main标签表示网页的主体部分-一个网页只能有一个" class="headerlink" title="main标签表示网页的主体部分(一个网页只能有一个)"></a>main标签表示网页的主体部分(一个网页只能有一个)</h3><h3 id="footer标签表示网页的底部"><a href="#footer标签表示网页的底部" class="headerlink" title="footer标签表示网页的底部"></a>footer标签表示网页的底部</h3><h3 id="nav标签表示网页中的导航"><a href="#nav标签表示网页中的导航" class="headerlink" title="nav标签表示网页中的导航"></a>nav标签表示网页中的导航</h3><h3 id="aside标签表示和主体相关的其他内容-侧边栏"><a href="#aside标签表示和主体相关的其他内容-侧边栏" class="headerlink" title="aside标签表示和主体相关的其他内容(侧边栏)"></a>aside标签表示和主体相关的其他内容(侧边栏)</h3><h3 id="article标签表示一个文章"><a href="#article标签表示一个文章" class="headerlink" title="article标签表示一个文章"></a>article标签表示一个文章</h3><h3 id="section表示一个独立的区块"><a href="#section表示一个独立的区块" class="headerlink" title="section表示一个独立的区块"></a>section表示一个独立的区块</h3><h3 id="div-没有意义-就用来表示一个区块"><a href="#div-没有意义-就用来表示一个区块" class="headerlink" title="div 没有意义,就用来表示一个区块."></a>div 没有意义,就用来表示一个区块.</h3><h3 id="span没有语义-行内元素"><a href="#span没有语义-行内元素" class="headerlink" title="span没有语义,行内元素,"></a>span没有语义,行内元素,</h3><hr><hr><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><h3 id="使用ul标签来创建有序列表-用li表示列表项"><a href="#使用ul标签来创建有序列表-用li表示列表项" class="headerlink" title="使用ul标签来创建有序列表,用li表示列表项"></a>使用ul标签来创建有序列表,用li表示列表项</h3><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><h3 id="使用ol标签来创建有序列表-用li表示列表项"><a href="#使用ol标签来创建有序列表-用li表示列表项" class="headerlink" title="使用ol标签来创建有序列表,用li表示列表项"></a>使用ol标签来创建有序列表,用li表示列表项</h3><h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><h3 id="使用dl标签来创建一个定义列表-用dt来表示定义的内容-使用dd来对内容进行解释说明"><a href="#使用dl标签来创建一个定义列表-用dt来表示定义的内容-使用dd来对内容进行解释说明" class="headerlink" title="使用dl标签来创建一个定义列表,用dt来表示定义的内容,使用dd来对内容进行解释说明"></a>使用dl标签来创建一个定义列表,用dt来表示定义的内容,使用dd来对内容进行解释说明</h3><h2 id="列表之间可以互相嵌套"><a href="#列表之间可以互相嵌套" class="headerlink" title="列表之间可以互相嵌套"></a>列表之间可以互相嵌套</h2><hr><hr><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="跳转页面-跳到当前页的某个位置"><a href="#跳转页面-跳到当前页的某个位置" class="headerlink" title="跳转页面,跳到当前页的某个位置"></a>跳转页面,跳到当前页的某个位置</h2><h3 id="使用-a-标签来定义超链接-行内元素-在a里除了它可以放任何元素"><a href="#使用-a-标签来定义超链接-行内元素-在a里除了它可以放任何元素" class="headerlink" title="使用 a 标签来定义超链接,行内元素,在a里除了它可以放任何元素"></a>使用 a 标签来定义超链接,行内元素,在a里除了它可以放任何元素</h3><h3 id="lt-a-href-quot-www-zhengtianhao-cn-quot-gt-博客-也可以跳自己编辑的页面-lt-a-gt"><a href="#lt-a-href-quot-www-zhengtianhao-cn-quot-gt-博客-也可以跳自己编辑的页面-lt-a-gt" class="headerlink" title="&lt;a href = &quot;www.zhengtianhao.cn&quot;&gt;博客//也可以跳自己编辑的页面&lt;/a&gt;"></a><code>&lt;a href = &quot;www.zhengtianhao.cn&quot;&gt;博客//也可以跳自己编辑的页面&lt;/a&gt;</code></h3><h3 id="当我们需要跳转到一个服务器内部的页面时-需要写相对路径-当前目录-可不写-上一级目录"><a href="#当我们需要跳转到一个服务器内部的页面时-需要写相对路径-当前目录-可不写-上一级目录" class="headerlink" title="当我们需要跳转到一个服务器内部的页面时,需要写相对路径(./当前目录(可不写);../上一级目录)"></a>当我们需要跳转到一个服务器内部的页面时,需要写相对路径(./当前目录(可不写);../上一级目录)</h3><h3 id="有target属性-用来指定超链打开的位置-可选值"><a href="#有target属性-用来指定超链打开的位置-可选值" class="headerlink" title="有target属性:用来指定超链打开的位置,可选值:"></a>有target属性:用来指定超链打开的位置,可选值:</h3><h3 id="self-默认值-在当前页面中打开超链接"><a href="#self-默认值-在当前页面中打开超链接" class="headerlink" title="_self 默认值 在当前页面中打开超链接;"></a>_self 默认值 在当前页面中打开超链接;</h3><h3 id="blank-在一个新的页面中代开链接"><a href="#blank-在一个新的页面中代开链接" class="headerlink" title="_blank:在一个新的页面中代开链接;"></a>_blank:在一个新的页面中代开链接;</h3><h3 id="可以直接将超链接的href属性设置为-这样点击超链接以后页面不会发生跳转-反而会到页面的顶部"><a href="#可以直接将超链接的href属性设置为-这样点击超链接以后页面不会发生跳转-反而会到页面的顶部" class="headerlink" title="可以直接将超链接的href属性设置为#,这样点击超链接以后页面不会发生跳转,反而会到页面的顶部,"></a>可以直接将超链接的href属性设置为#,这样点击超链接以后页面不会发生跳转,反而会到页面的顶部,</h3><h3 id="每一个属性都可以添加一个id属性-可以跳到页面的指定位置-只要将href属性设置为-目标元素的id值"><a href="#每一个属性都可以添加一个id属性-可以跳到页面的指定位置-只要将href属性设置为-目标元素的id值" class="headerlink" title="每一个属性都可以添加一个id属性,可以跳到页面的指定位置,只要将href属性设置为 #目标元素的id值"></a>每一个属性都可以添加一个id属性,可以跳到页面的指定位置,只要将href属性设置为 #目标元素的id值</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">a</span> href = <span class="string">&quot;#zombie&quot;</span>&gt;去底部&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line">.</span><br><span class="line"><span class="comment">.//javascript:;  什么都不会发生</span></span><br><span class="line">.</span><br><span class="line">&lt;<span class="keyword">a</span> id = <span class="string">&quot;botton&quot;</span> href = <span class="string">&quot;#&quot;</span>&gt;回到顶部&lt;/<span class="keyword">a</span>&gt;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h1><h2 id="使用img标签来引入外部标签-img标签是一个自结果标签-属于替换元素"><a href="#使用img标签来引入外部标签-img标签是一个自结果标签-属于替换元素" class="headerlink" title="使用img标签来引入外部标签,img标签是一个自结果标签,属于替换元素"></a>使用img标签来引入外部标签,img标签是一个自结果标签,属于替换元素</h2><h3 id="src指定外部标签的路径-alt图片的描述-用于浏览器搜索引擎识别图片-类似id-id是唯一的-它是一类"><a href="#src指定外部标签的路径-alt图片的描述-用于浏览器搜索引擎识别图片-类似id-id是唯一的-它是一类" class="headerlink" title="src指定外部标签的路径;alt图片的描述,用于浏览器搜索引擎识别图片,类似id,id是唯一的,它是一类"></a>src指定外部标签的路径;alt图片的描述,用于浏览器搜索引擎识别图片,类似id,id是唯一的,它是一类</h3><h3 id="还有属性宽和高"><a href="#还有属性宽和高" class="headerlink" title="还有属性宽和高"></a>还有属性宽和高</h3><h3 id="lt-img-src-quot-图片地址-quot-alt-“图片描述”-gt"><a href="#lt-img-src-quot-图片地址-quot-alt-“图片描述”-gt" class="headerlink" title="&lt;img src = &quot;图片地址&quot; alt = “图片描述”&gt;"></a><code>&lt;img src = &quot;图片地址&quot;</code> alt = “图片描述”&gt;</h3><h2 id="图片的格式"><a href="#图片的格式" class="headerlink" title="图片的格式"></a>图片的格式</h2><h3 id="jpg-支持的颜色比较丰富-不支持动图和透明效果-一般用来显示照片"><a href="#jpg-支持的颜色比较丰富-不支持动图和透明效果-一般用来显示照片" class="headerlink" title="jpg:支持的颜色比较丰富,不支持动图和透明效果,一般用来显示照片"></a>jpg:支持的颜色比较丰富,不支持动图和透明效果,一般用来显示照片</h3><h3 id="gif-支持的颜色比较少-支持简单透明-支持动图-一般用于颜色单一的图片-动图"><a href="#gif-支持的颜色比较少-支持简单透明-支持动图-一般用于颜色单一的图片-动图" class="headerlink" title="gif:支持的颜色比较少,支持简单透明,支持动图,一般用于颜色单一的图片,动图"></a>gif:支持的颜色比较少,支持简单透明,支持动图,一般用于颜色单一的图片,动图</h3><h3 id="png-支持的颜色丰富-支持复杂透明-不支持动图-一般用于复杂透明和颜色丰富的图片"><a href="#png-支持的颜色丰富-支持复杂透明-不支持动图-一般用于复杂透明和颜色丰富的图片" class="headerlink" title="png:支持的颜色丰富,支持复杂透明,不支持动图,一般用于复杂透明和颜色丰富的图片"></a>png:支持的颜色丰富,支持复杂透明,不支持动图,一般用于复杂透明和颜色丰富的图片</h3><h3 id="webp-这种格式是谷歌新推出的专门用来表示网页图片的一种格式-小还具备以上有点"><a href="#webp-这种格式是谷歌新推出的专门用来表示网页图片的一种格式-小还具备以上有点" class="headerlink" title="webp:这种格式是谷歌新推出的专门用来表示网页图片的一种格式,小还具备以上有点"></a>webp:这种格式是谷歌新推出的专门用来表示网页图片的一种格式,小还具备以上有点</h3><h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><h3 id="将图片使用base64编码-这样可以将图片转换为字符-通过字符的形式将图片引入-用于图片与网页一起展现"><a href="#将图片使用base64编码-这样可以将图片转换为字符-通过字符的形式将图片引入-用于图片与网页一起展现" class="headerlink" title="将图片使用base64编码,这样可以将图片转换为字符,通过字符的形式将图片引入,用于图片与网页一起展现"></a>将图片使用base64编码,这样可以将图片转换为字符,通过字符的形式将图片引入,用于图片与网页一起展现</h3><hr><hr><h1 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h1><h2 id="用于向当前页面中引入一个页面-src-指定要引入的页面的路径-frameborder指定内联框架的边框"><a href="#用于向当前页面中引入一个页面-src-指定要引入的页面的路径-frameborder指定内联框架的边框" class="headerlink" title="用于向当前页面中引入一个页面 ; src 指定要引入的页面的路径;frameborder指定内联框架的边框"></a>用于向当前页面中引入一个页面 ; src 指定要引入的页面的路径;frameborder指定内联框架的边框</h2><h3 id="lt-iframe-src-quot-wwww-zhengtianhao-cn-quot-width-quot-500-quot-height-quot-500-quot-frameborder-quot-1-quot-gt-lt-iframe-gt"><a href="#lt-iframe-src-quot-wwww-zhengtianhao-cn-quot-width-quot-500-quot-height-quot-500-quot-frameborder-quot-1-quot-gt-lt-iframe-gt" class="headerlink" title="&lt;iframe src = &quot;wwww.zhengtianhao.cn&quot; width = &quot;500&quot; height = &quot;500&quot; frameborder=&quot;1&quot;&gt;&lt;/iframe&gt;"></a><code>&lt;iframe src = &quot;wwww.zhengtianhao.cn&quot; width = &quot;500&quot; height = &quot;500&quot; frameborder=&quot;1&quot;&gt;&lt;/iframe&gt;</code></h3><hr><hr><h1 id="音视频播放"><a href="#音视频播放" class="headerlink" title="音视频播放"></a>音视频播放</h1><h2 id="audio-标签用来向页面中引入一个外部的音频文件"><a href="#audio-标签用来向页面中引入一个外部的音频文件" class="headerlink" title="audio 标签用来向页面中引入一个外部的音频文件"></a>audio 标签用来向页面中引入一个外部的音频文件</h2><h2 id="音视频文件引入时-默认情况下不允许用户自己控制播放停止"><a href="#音视频文件引入时-默认情况下不允许用户自己控制播放停止" class="headerlink" title="音视频文件引入时,默认情况下不允许用户自己控制播放停止"></a>音视频文件引入时,默认情况下不允许用户自己控制播放停止</h2><h2 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h2><h2 id="controls是否允许用户控制播放"><a href="#controls是否允许用户控制播放" class="headerlink" title="controls是否允许用户控制播放;"></a>controls是否允许用户控制播放;</h2><h2 id="autoplay音频文件是否自动播放"><a href="#autoplay音频文件是否自动播放" class="headerlink" title="autoplay音频文件是否自动播放;"></a>autoplay音频文件是否自动播放;</h2><h2 id="loop循环播放"><a href="#loop循环播放" class="headerlink" title="loop循环播放;"></a>loop循环播放;</h2><h2 id="lt-audio-src-quot-相对路径-quot-controls-autoplay-gt-lt-audio-gt-有些不可以自动播放是浏览器的锅-大部分都对音乐取消自动播放"><a href="#lt-audio-src-quot-相对路径-quot-controls-autoplay-gt-lt-audio-gt-有些不可以自动播放是浏览器的锅-大部分都对音乐取消自动播放" class="headerlink" title="&lt;audio src = &quot;相对路径&quot; controls autoplay&gt;&lt;/audio&gt;//有些不可以自动播放是浏览器的锅(大部分都对音乐取消自动播放)"></a><code>&lt;audio src = &quot;相对路径&quot; controls autoplay&gt;&lt;/audio&gt;</code>//有些不可以自动播放是浏览器的锅(大部分都对音乐取消自动播放)</h2><h3 id="浏览器不支持mp3可以写ogg"><a href="#浏览器不支持mp3可以写ogg" class="headerlink" title="浏览器不支持mp3可以写ogg"></a>浏览器不支持mp3可以写ogg</h3><h2 id="video标签来向页面中引入一个视频"><a href="#video标签来向页面中引入一个视频" class="headerlink" title="video标签来向页面中引入一个视频"></a>video标签来向页面中引入一个视频</h2><h3 id="浏览器不支持mp4可以写webm"><a href="#浏览器不支持mp4可以写webm" class="headerlink" title="浏览器不支持mp4可以写webm"></a>浏览器不支持mp4可以写webm</h3><hr><hr><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><hr><hr><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><hr><hr>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%A0%B7%E5%BC%8F/">样式</category>
      
      
      <category domain="http://example.com/tags/%E5%AF%BC%E8%88%AA/">导航</category>
      
      <category domain="http://example.com/tags/%E5%88%86%E4%BA%AB/">分享</category>
      
      
      <comments>http://example.com/2021/06/11/HTML/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
